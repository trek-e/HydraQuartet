---
phase: 07-hard-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
autonomous: true

must_haves:
  truths:
    - "User can enable VCO1 sync to VCO2 and hear classic sync sweep sound"
    - "User can enable VCO2 sync to VCO1 for reverse sync"
    - "User can sweep synced oscillator pitch without clicks or digital artifacts"
    - "Bidirectional sync produces phase-locked or chaotic patterns at different ratios"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "Hard sync DSP with MinBLEP antialiasing"
      contains: "sync1Enabled"
  key_links:
    - from: "VcoEngine::process()"
      to: "HydraQuartetVCO::process()"
      via: "wrap mask return value"
      pattern: "wrapMask"
    - from: "sync reset"
      to: "MinBlepBuffer::insertDiscontinuity()"
      via: "per-waveform discontinuity calculation"
      pattern: "insertDiscontinuity.*sync"
---

<objective>
Implement hard oscillator sync with MinBLEP antialiasing

Purpose: Hard sync is a classic synthesizer technique for creating harmonic-rich timbres. When VCO1 syncs to VCO2, VCO1's phase resets at each VCO2 cycle, producing the characteristic "sync sweep" sound. Proper antialiasing prevents aliasing artifacts from the phase discontinuity.

Output: Working hard sync on both VCOs with clean, alias-free sync sweeps
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hard-sync/07-CONTEXT.md
@.planning/phases/07-hard-sync/07-RESEARCH.md
@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify VcoEngine to return wrap mask and accept sync reset</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Modify the VcoEngine::process() signature to support hard sync:

1. Add output parameter for wrap mask:
```cpp
void process(int g, float_4 freq, float sampleTime, float_4 pwm,
             float_4& saw, float_4& sqr, float_4& tri, float_4& sine,
             int& wrapMask);  // NEW: returns which lanes wrapped
```

2. The existing code already computes `wrapMask = simd::movemask(wrapped)` at line 92. Return this value via the new output parameter.

3. Store `oldPhase` and `deltaPhase` as member variables so they can be accessed for sync calculations:
```cpp
// Add to VcoEngine struct (after phase[4])
float_4 oldPhase[4] = {};
float_4 deltaPhase[4] = {};
```

4. In process(), store these values before modifying phase:
```cpp
deltaPhase[g] = simd::clamp(freq * sampleTime, 0.f, 0.49f);
oldPhase[g] = phase[g];
phase[g] += deltaPhase[g];
```

5. Add a separate sync method to apply external sync reset:
```cpp
void applySync(int g, int syncMask, float_4 masterOldPhase, float_4 masterDeltaPhase, float_4 pwm);
```

This method will:
- Calculate subsample position: `(1.f - masterOldPhase[i]) / masterDeltaPhase[i] - 1.f`
- Store old waveform values before reset
- Reset phase to subsample-accurate position: `deltaPhase[g][i] * (-subsample)`
- Calculate new waveform values after reset
- Insert MinBLEP discontinuities for sawtooth, square, and triangle

DO NOT insert MinBLEP for sine (it's continuous, per research).
  </action>
  <verify>Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`</verify>
  <done>VcoEngine has process() returning wrapMask and applySync() method for external sync reset</done>
</task>

<task type="auto">
  <name>Task 2: Implement bidirectional hard sync in process loop</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
In HydraQuartetVCO::process(), implement the hard sync logic:

1. Read sync switch states (outside the SIMD loop):
```cpp
bool sync1Enabled = params[SYNC1_PARAM].getValue() > 0.5f;  // VCO1 syncs to VCO2
bool sync2Enabled = params[SYNC2_PARAM].getValue() > 0.5f;  // VCO2 syncs to VCO1
```

2. Inside the SIMD loop, change the processing order to support bidirectional sync:
   a. Process VCO1 first, get its wrapMask
   b. Process VCO2 second, get its wrapMask
   c. Apply sync resets AFTER both VCOs have processed

3. Replace the existing vco1.process() and vco2.process() calls with:
```cpp
int vco1WrapMask, vco2WrapMask;
vco1.process(g, freq1, sampleTime, pwm1_4, saw1, sqr1, tri1, sine1, vco1WrapMask);
vco2.process(g, freq2, sampleTime, pwm2_4, saw2, sqr2, tri2, sine2, vco2WrapMask);

// Apply sync resets (order matters for bidirectional)
if (sync1Enabled && vco2WrapMask) {
    // VCO1 syncs to VCO2: when VCO2 wraps, reset VCO1
    vco1.applySync(g, vco2WrapMask, vco2.oldPhase[g], vco2.deltaPhase[g], pwm1_4);
}
if (sync2Enabled && vco1WrapMask) {
    // VCO2 syncs to VCO1: when VCO1 wraps, reset VCO2
    vco2.applySync(g, vco1WrapMask, vco1.oldPhase[g], vco1.deltaPhase[g], pwm2_4);
}
```

4. Important: When applying sync, the waveform outputs (saw1, sqr1, etc.) need to be recalculated after the sync reset. The applySync() method should update the waveform outputs based on the new phase. Consider refactoring to either:
   - Have applySync() return the corrected waveform values, OR
   - Recalculate waveforms after all sync operations

Research recommends: Process phase increment and wrap detection, then apply sync resets, then generate waveforms. This may require restructuring VcoEngine::process() into separate steps.

CRITICAL: Per CONTEXT.md decision #4, only trigger sync on positive deltaPhase (prevents crashes when FM makes frequency negative).
  </action>
  <verify>Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`</verify>
  <done>Bidirectional hard sync implemented with correct processing order</done>
</task>

<task type="auto">
  <name>Task 3: Implement MinBLEP discontinuity insertion for sync</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Implement the applySync() method with per-waveform MinBLEP discontinuity calculation:

```cpp
void applySync(int g, int syncMask, float_4 masterOldPhase, float_4 masterDeltaPhase, float_4 pwm) {
    for (int i = 0; i < 4; i++) {
        if (!(syncMask & (1 << i))) continue;
        if (deltaPhase[g][i] <= 0.f) continue;  // Skip if negative freq (FM)
        if (masterDeltaPhase[i] <= 0.f) continue;  // Skip if master freq negative

        // Calculate subsample position of master wrap
        float subsample = (1.f - masterOldPhase[i]) / masterDeltaPhase[i] - 1.f;
        subsample = clamp(subsample, -1.f + 1e-6f, 0.f);  // Ensure valid range

        // Calculate old waveform values (at current phase, before reset)
        float currentPhase = phase[g][i];
        float oldSaw = 2.f * currentPhase - 1.f;
        float oldSqr = (currentPhase < pwm[i]) ? 1.f : -1.f;
        float oldTri = (currentPhase < 0.5f)
            ? (4.f * currentPhase - 1.f)
            : (3.f - 4.f * currentPhase);

        // Reset phase to subsample-accurate position
        float newPhase = deltaPhase[g][i] * (-subsample);
        phase[g][i] = newPhase;

        // Calculate new waveform values (at reset phase)
        float newSaw = 2.f * newPhase - 1.f;
        float newSqr = (newPhase < pwm[i]) ? 1.f : -1.f;
        float newTri = (newPhase < 0.5f)
            ? (4.f * newPhase - 1.f)
            : (3.f - 4.f * newPhase);

        // Insert MinBLEP discontinuities
        sawMinBlepBuffer[g].insertDiscontinuity(subsample, newSaw - oldSaw, i);

        // Square: only insert if value actually changed
        if (oldSqr != newSqr) {
            sqrMinBlepBuffer[g].insertDiscontinuity(subsample, newSqr - oldSqr, i);
        }

        // Triangle: insert discontinuity (slope handled by existing integration)
        // Note: Research indicates existing square integration method handles triangle
        // automatically, but sync requires explicit BLEP for amplitude jump
        sqrMinBlepBuffer[g].insertDiscontinuity(subsample, newTri - oldTri, i);
        // WARNING: Triangle uses sqrMinBlepBuffer in existing code (via integration)
        // May need separate triMinBlepBuffer or verify this works correctly
    }
}
```

IMPORTANT: The existing triangle implementation uses direct calculation (not square integration). Review line 130-132 in current code. Triangle sync may need its own MinBLEP buffer or the discontinuity can be handled differently.

Per research: "Triangle via direct calculation" means triangle has explicit amplitude discontinuity at sync, needs BLEP. Consider adding triMinBlepBuffer to VcoEngine if triangle sync sounds clicky.

Sine: No MinBLEP needed (continuous waveform). Sine hard sync will have some aliasing (known limitation per research).

After implementing, verify builds and test in VCV Rack:
1. Set VCO1 and VCO2 to same pitch
2. Enable VCO2 sync to VCO1 (SYNC2_PARAM = Hard)
3. Slowly increase VCO2 octave from 0 to +2
4. Should hear harmonic sweep without clicks
  </action>
  <verify>
1. Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`
2. Module loads in VCV Rack without crash
3. Enable sync and sweep - no loud clicks or pops
  </verify>
  <done>MinBLEP discontinuities correctly inserted for sawtooth and square; triangle and sine handled appropriately</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
```bash
make -C /Users/trekkie/projects/vcvrack_modules/vco -j4 2>&1 | tail -20
```

2. Functional testing in VCV Rack:
- Load HydraQuartetVCO
- Connect V/Oct to keyboard/sequencer
- Enable SYNC2 (VCO2 syncs to VCO1)
- Play a note, sweep VCO2 OCTAVE from 0 to +2
- Expected: Classic sync sweep sound, harmonic content increases, no clicks

3. Reverse sync test:
- Enable SYNC1 (VCO1 syncs to VCO2), disable SYNC2
- Sweep VCO1 with DETUNE knob
- Expected: Similar sync effect in reverse direction

4. Bidirectional sync test:
- Enable both SYNC1 and SYNC2
- Set identical pitch: should phase-lock (stable tone)
- Set different octaves: should produce complex patterns

5. FM + Sync interaction test:
- Enable FM (FM knob > 0) and SYNC2
- Modulate FM depth
- Expected: Should work without crashes (sync only triggers on positive freq)
</verification>

<success_criteria>
- [x] SYNC1_PARAM controls whether VCO1 syncs to VCO2 phase wrap
- [x] SYNC2_PARAM controls whether VCO2 syncs to VCO1 phase wrap
- [x] Sync resets phase at subsample-accurate position
- [x] MinBLEP discontinuities inserted for sawtooth waveform
- [x] MinBLEP discontinuities inserted for square waveform (when value changes)
- [x] Triangle handled (either via MinBLEP or accepted aliasing)
- [x] Sine has no MinBLEP (continuous, accepted aliasing)
- [x] No crashes when FM makes frequency negative
- [x] Classic sync sweep sounds clean (no clicks)
- [x] Bidirectional sync works (both can reset each other)
</success_criteria>

<output>
After completion, create `.planning/phases/07-hard-sync/07-01-SUMMARY.md`
</output>
