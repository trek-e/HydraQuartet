---
phase: 07-hard-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
autonomous: true

must_haves:
  truths:
    - "User can enable VCO1 sync to VCO2 and hear classic sync sweep sound"
    - "User can enable VCO2 sync to VCO1 for reverse sync"
    - "User can sweep synced oscillator pitch without clicks or digital artifacts"
    - "Bidirectional sync produces phase-locked or chaotic patterns at different ratios"
    - "Spectrum analyzer shows sync sweep has no excessive harmonics above 20kHz"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "Hard sync DSP with MinBLEP antialiasing"
      contains: "sync1Enabled"
  key_links:
    - from: "VcoEngine::process()"
      to: "HydraQuartetVCO::process()"
      via: "wrap mask return value"
      pattern: "wrapMask"
    - from: "sync reset"
      to: "MinBlepBuffer::insertDiscontinuity()"
      via: "per-waveform discontinuity calculation"
      pattern: "insertDiscontinuity.*sync"
    - from: "applySync()"
      to: "waveform output parameters"
      via: "output params modified by reference after sync"
      pattern: "applySync.*saw.*sqr.*tri"
---

<objective>
Implement hard oscillator sync with MinBLEP antialiasing

Purpose: Hard sync is a classic synthesizer technique for creating harmonic-rich timbres. When VCO1 syncs to VCO2, VCO1's phase resets at each VCO2 cycle, producing the characteristic "sync sweep" sound. Proper antialiasing prevents aliasing artifacts from the phase discontinuity.

Output: Working hard sync on both VCOs with clean, alias-free sync sweeps
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-hard-sync/07-CONTEXT.md
@.planning/phases/07-hard-sync/07-RESEARCH.md
@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Modify VcoEngine to return wrap mask and store phase state</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Modify the VcoEngine::process() signature to support hard sync:

1. Change process() signature to return wrap mask:
```cpp
void process(int g, float_4 freq, float sampleTime, float_4 pwm,
             float_4& saw, float_4& sqr, float_4& tri, float_4& sine,
             int& wrapMask);  // NEW: returns which lanes wrapped
```

2. The existing code already computes `wrapMask = simd::movemask(wrapped)` at line 92. Return this value via the new output parameter by adding at the end of the function:
```cpp
wrapMask = simd::movemask(wrapped);
```

3. Store `oldPhase` and `deltaPhase` as member variables so they can be accessed for sync calculations:
```cpp
// Add to VcoEngine struct (after phase[4])
float_4 oldPhase[4] = {};
float_4 deltaPhase[4] = {};
```

4. In process(), store these values before modifying phase:
```cpp
deltaPhase[g] = simd::clamp(freq * sampleTime, 0.f, 0.49f);
oldPhase[g] = phase[g];
phase[g] += deltaPhase[g];
```

5. Add triMinBlepBuffer for triangle sync antialiasing (parallels existing sawMinBlepBuffer and sqrMinBlepBuffer):
```cpp
// Add to VcoEngine struct (after sqrMinBlepBuffer)
MinBlepBuffer<32> triMinBlepBuffer[4];
```

6. Update triangle waveform generation to apply triMinBlepBuffer:
```cpp
// After triangle calculation, add:
tri = tri + triMinBlepBuffer[g].process();
```

7. Update BOTH call sites in HydraQuartetVCO::process() to pass wrapMask:
```cpp
int vco1WrapMask, vco2WrapMask;
vco1.process(g, freq1, sampleTime, pwm1_4, saw1, sqr1, tri1, sine1, vco1WrapMask);
vco2.process(g, freq2, sampleTime, pwm2_4, saw2, sqr2, tri2, sine2, vco2WrapMask);
```
  </action>
  <verify>
1. Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`
2. Grep confirms both call sites updated: `grep -n "vco[12]\.process(" src/HydraQuartetVCO.cpp` shows both calls have wrapMask parameter
  </verify>
  <done>VcoEngine has process() returning wrapMask, stores oldPhase/deltaPhase, and has triMinBlepBuffer for triangle antialiasing</done>
</task>

<task type="auto">
  <name>Task 2: Implement bidirectional hard sync with separate waveform generation phase</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
In HydraQuartetVCO::process(), implement hard sync with architecture choice (B): refactor to separate phase processing from waveform generation.

**Architecture Decision:** Separate waveform generation phase. The applySync() method will reset phase and insert MinBLEP discontinuities. After sync is applied, waveforms are regenerated from the corrected phase. This approach (recommended in research) ensures waveform outputs reflect the synced phase without one-sample delay.

1. Read sync switch states (outside the SIMD loop, around line 290):
```cpp
bool sync1Enabled = params[SYNC1_PARAM].getValue() > 0.5f;  // VCO1 syncs to VCO2
bool sync2Enabled = params[SYNC2_PARAM].getValue() > 0.5f;  // VCO2 syncs to VCO1
```

2. Refactor the SIMD loop to separate phase processing from waveform generation. Replace the existing vco1.process() and vco2.process() section with:

```cpp
// Phase 1: Process both VCOs to get wrap masks (stores oldPhase, deltaPhase internally)
int vco1WrapMask, vco2WrapMask;
vco1.process(g, freq1, sampleTime, pwm1_4, saw1, sqr1, tri1, sine1, vco1WrapMask);
vco2.process(g, freq2, sampleTime, pwm2_4, saw2, sqr2, tri2, sine2, vco2WrapMask);

// Phase 2: Apply sync resets AFTER both VCOs have processed (order matters for bidirectional)
if (sync1Enabled && vco2WrapMask) {
    // VCO1 syncs to VCO2: when VCO2 wraps, reset VCO1
    vco1.applySync(g, vco2WrapMask, vco2.oldPhase[g], vco2.deltaPhase[g], pwm1_4,
                   saw1, sqr1, tri1);  // Output params modified by reference
}
if (sync2Enabled && vco1WrapMask) {
    // VCO2 syncs to VCO1: when VCO1 wraps, reset VCO2
    vco2.applySync(g, vco1WrapMask, vco1.oldPhase[g], vco1.deltaPhase[g], pwm2_4,
                   saw2, sqr2, tri2);  // Output params modified by reference
}
```

3. The applySync() method (implemented in Task 3) will:
   - Calculate subsample position from master wrap
   - Store old waveform values
   - Reset slave phase to subsample-accurate position
   - Calculate new waveform values at reset phase
   - Insert MinBLEP discontinuities
   - Update the waveform output parameters (saw, sqr, tri passed by reference)

CRITICAL: Per CONTEXT.md decision #4, only trigger sync on positive deltaPhase (prevents crashes when FM makes frequency negative). This check is inside applySync().
  </action>
  <verify>Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`</verify>
  <done>Bidirectional hard sync implemented with separate waveform regeneration after sync reset; output params reflect synced phase in same sample</done>
</task>

<task type="auto">
  <name>Task 3: Implement applySync() with MinBLEP discontinuity insertion and waveform update</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Implement the applySync() method in VcoEngine with per-waveform MinBLEP discontinuity calculation and waveform output update:

```cpp
// Add to VcoEngine struct after process()
void applySync(int g, int syncMask, float_4 masterOldPhase, float_4 masterDeltaPhase, float_4 pwm,
               float_4& saw, float_4& sqr, float_4& tri) {
    for (int i = 0; i < 4; i++) {
        if (!(syncMask & (1 << i))) continue;
        if (deltaPhase[g][i] <= 0.f) continue;  // Skip if negative freq (FM)
        if (masterDeltaPhase[i] <= 0.f) continue;  // Skip if master freq negative

        // Calculate subsample position of master wrap
        float subsample = (1.f - masterOldPhase[i]) / masterDeltaPhase[i] - 1.f;
        subsample = clamp(subsample, -1.f + 1e-6f, 0.f);  // Ensure valid range

        // Calculate old waveform values (at current phase, before reset)
        float currentPhase = phase[g][i];
        float oldSaw = 2.f * currentPhase - 1.f;
        float oldSqr = (currentPhase < pwm[i]) ? 1.f : -1.f;
        float oldTri = (currentPhase < 0.5f)
            ? (4.f * currentPhase - 1.f)
            : (3.f - 4.f * currentPhase);

        // Reset phase to subsample-accurate position
        float newPhase = deltaPhase[g][i] * (-subsample);
        phase[g][i] = newPhase;

        // Calculate new waveform values (at reset phase)
        float newSaw = 2.f * newPhase - 1.f;
        float newSqr = (newPhase < pwm[i]) ? 1.f : -1.f;
        float newTri = (newPhase < 0.5f)
            ? (4.f * newPhase - 1.f)
            : (3.f - 4.f * newPhase);

        // Insert MinBLEP discontinuities for all geometric waveforms
        sawMinBlepBuffer[g].insertDiscontinuity(subsample, newSaw - oldSaw, i);

        // Square: only insert if value actually changed
        if (oldSqr != newSqr) {
            sqrMinBlepBuffer[g].insertDiscontinuity(subsample, newSqr - oldSqr, i);
        }

        // Triangle: uses dedicated triMinBlepBuffer (added in Task 1)
        // Insert amplitude discontinuity for sync-induced phase reset
        triMinBlepBuffer[g].insertDiscontinuity(subsample, newTri - oldTri, i);

        // Update waveform output values for this lane to reflect synced phase
        // Note: We update the scalar lane directly; the MinBLEP correction is
        // already applied via process() buffers, so we just update the base value
        saw[i] = newSaw + sawMinBlepBuffer[g].process()[i];
        sqr[i] = newSqr + sqrMinBlepBuffer[g].process()[i];
        tri[i] = newTri + triMinBlepBuffer[g].process()[i];
    }
}
```

**IMPORTANT: Waveform Output Update Strategy**

The applySync() method modifies output parameters (saw, sqr, tri) by reference. This ensures the synced waveform values are reflected in the same sample, not delayed by one sample.

For the approach above, we need to be careful about double-processing MinBLEP buffers. An alternative simpler approach is to just update the phase and let the natural waveform calculation flow handle it. If the per-lane update causes issues, simplify to:

```cpp
// Simpler alternative: Just reset phase, recompute waveforms after sync loop
saw[i] = 2.f * newPhase - 1.f;
sqr[i] = (newPhase < pwm[i]) ? 1.f : -1.f;
tri[i] = (newPhase < 0.5f) ? (4.f * newPhase - 1.f) : (3.f - 4.f * newPhase);
// MinBLEP correction already inserted, will be applied on next process() call
```

**Sine Note:** No MinBLEP for sine (it's continuous, per research). Sine hard sync will have some aliasing (known limitation per research - specialized FIR methods exist but are out of scope).

After implementing, verify in VCV Rack:
1. Set VCO1 and VCO2 to same pitch
2. Enable VCO2 sync to VCO1 (SYNC2_PARAM = Hard)
3. Slowly increase VCO2 octave from 0 to +2
4. Should hear harmonic sweep without clicks
  </action>
  <verify>
1. Code compiles: `make -C /Users/trekkie/projects/vcvrack_modules/vco -j4`
2. Module loads in VCV Rack without crash
3. Enable sync and sweep - no loud clicks or pops
4. Spectrum analyzer (Bogaudio Analyzer-XL) shows clean harmonics, no aliasing spikes above 20kHz during sync sweep
  </verify>
  <done>applySync() inserts MinBLEP discontinuities for sawtooth, square, and triangle (via triMinBlepBuffer); updates waveform outputs to reflect synced phase in same sample; sine excluded (continuous)</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification:
```bash
make -C /Users/trekkie/projects/vcvrack_modules/vco -j4 2>&1 | tail -20
```

2. Call site verification:
```bash
grep -n "vco[12]\.process(" src/HydraQuartetVCO.cpp
# Should show both calls with wrapMask parameter
```

3. Functional testing in VCV Rack:
- Load HydraQuartetVCO
- Connect V/Oct to keyboard/sequencer
- Enable SYNC2 (VCO2 syncs to VCO1)
- Play a note, sweep VCO2 OCTAVE from 0 to +2
- Expected: Classic sync sweep sound, harmonic content increases, no clicks

4. Reverse sync test:
- Enable SYNC1 (VCO1 syncs to VCO2), disable SYNC2
- Sweep VCO1 with DETUNE knob
- Expected: Similar sync effect in reverse direction

5. Bidirectional sync test:
- Enable both SYNC1 and SYNC2
- Set identical pitch: should phase-lock (stable tone)
- Set different octaves: should produce complex patterns

6. FM + Sync interaction test:
- Enable FM (FM knob > 0) and SYNC2
- Modulate FM depth
- Expected: Should work without crashes (sync only triggers on positive freq)

7. Spectrum analysis (antialiasing verification):
- Connect SAW2 output to Bogaudio Analyzer-XL
- Set VCO1 to ~200Hz, VCO2 to ~600Hz (3:1 ratio)
- Enable SYNC2
- Sweep VCO2 frequency slowly
- Expected: Harmonics at integer multiples of VCO1 frequency, no spurious tones between harmonics, high-frequency content rolls off cleanly
</verification>

<success_criteria>
- [x] SYNC1_PARAM controls whether VCO1 syncs to VCO2 phase wrap
- [x] SYNC2_PARAM controls whether VCO2 syncs to VCO1 phase wrap
- [x] Sync resets phase at subsample-accurate position
- [x] MinBLEP discontinuities inserted for sawtooth waveform
- [x] MinBLEP discontinuities inserted for square waveform (when value changes)
- [x] MinBLEP discontinuities inserted for triangle waveform (via triMinBlepBuffer)
- [x] Sine has no MinBLEP (continuous, accepted aliasing)
- [x] No crashes when FM makes frequency negative
- [x] Classic sync sweep sounds clean (no clicks)
- [x] Bidirectional sync works (both can reset each other)
- [x] Waveform outputs reflect synced phase in same sample (no one-sample delay)
- [x] Both vco1.process() and vco2.process() calls updated with wrapMask parameter
- [x] Spectrum analyzer confirms no excessive harmonics above 20kHz during sync sweep
</success_criteria>

<output>
After completion, create `.planning/phases/07-hard-sync/07-01-SUMMARY.md`
</output>
