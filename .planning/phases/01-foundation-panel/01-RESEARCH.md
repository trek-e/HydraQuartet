# Phase 1: Foundation & Panel - Research

**Researched:** 2026-01-22
**Domain:** VCV Rack SDK plugin development, panel design, polyphonic synthesis
**Confidence:** HIGH

## Summary

VCV Rack SDK 2.6 plugin development follows a well-established workflow: use `helper.py` to scaffold projects and modules from SVG panels, implement modules in C++ extending the Module base class, and build with standard Makefiles. The SDK enforces strict C++11 compliance and provides comprehensive DSP utilities.

For 36 HP polyphonic VCO modules, the standard approach uses SIMD float_4 processing (4 channels at once) to handle 8-16 voice polyphony efficiently. Panel design in Inkscape follows precise measurement standards (36 HP = 182.88mm width, 128.5mm height) with color-coded component layers that helper.py converts to C++ code automatically.

V/Oct pitch tracking uses the exponential formula `frequency = dsp::FREQ_C4 * 2^pitch`, with `dsp::exp2_taylor5()` providing fast approximation. VCV's voltage standards are well-defined: ±5V nominal audio, 10V gates, 1V/octave pitch control with C4 (261.6256 Hz) at 0V.

**Primary recommendation:** Start with helper.py to generate plugin skeleton, design 36 HP panel in Inkscape with proper component layer colors, implement polyphonic processing with float_4 SIMD for 8 voices, and use established DSP utilities rather than custom implementations.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| VCV Rack SDK | 2.6+ | Plugin development framework | Official SDK, required for all plugins |
| C++11 | Standard | Core language | Mandatory SDK requirement, no C++14/17 features |
| SIMD (float_4) | Built-in | Polyphonic processing | 4x performance vs scalar, SDK provides simd:: namespace |
| dsp namespace | SDK built-in | Audio DSP utilities | Optimized, tested, covers pitch/filters/triggers/FFT |
| Inkscape | Latest | SVG panel design | Free, cross-platform, native SVG export, helper.py compatible |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| helper.py | SDK included | Code generation from SVG | Always - generates plugin.json, module templates, panel code |
| rack:: namespace | SDK built-in | Engine, widgets, UI | Module/widget classes, input/output handling |
| pffft | SDK included | FFT operations | Spectrum analysis, frequency domain processing |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Inkscape | Adobe Illustrator | Illustrator works but must export properly (inline styles, convert to outlines) |
| SIMD float_4 | Scalar per-channel loops | ~4x worse CPU performance, only justified if algorithm can't vectorize |
| dsp::exp2_taylor5() | std::pow(2.f, x) | std::pow is 10-100x slower, no audible benefit |

**Installation:**
```bash
# Download Rack SDK from vcvrack.com (Windows x64 / Mac x64 / Mac ARM64 / Linux x64)
export RACK_DIR=/path/to/Rack-SDK

# Create plugin with helper.py
$RACK_DIR/helper.py createplugin MyPlugin

# Create module from SVG panel
$RACK_DIR/helper.py createmodule MyModule res/MyModule.svg src/MyModule.cpp
```

## Architecture Patterns

### Recommended Project Structure
```
MyPlugin/
├── plugin.json          # Manifest (generated by helper.py)
├── plugin.hpp           # Plugin-level declarations
├── plugin.cpp           # Plugin initialization
├── Makefile             # Build configuration (uses RACK_DIR)
├── src/
│   └── MyModule.cpp     # Module implementation
├── res/
│   └── MyModule.svg     # Panel design (Inkscape)
└── .git/                # Version control
```

### Pattern 1: Polyphonic Module Structure
**What:** Module class with SIMD float_4 processing for 8-16 channels
**When to use:** Any module handling polyphonic cables (standard for modern VCV modules)

**Example:**
```cpp
// Source: https://vcvrack.com/manual/PluginGuide
struct MyVCO : Module {
    enum ParamIds { PITCH_PARAM, NUM_PARAMS };
    enum InputIds { VOCT_INPUT, NUM_INPUTS };
    enum OutputIds { AUDIO_OUTPUT, NUM_OUTPUTS };
    enum LightIds { NUM_LIGHTS };

    // State for 4 channels processed simultaneously (16 channels total = 4 iterations)
    float_4 phase[4] = {};

    MyVCO() {
        config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);
        configParam(PITCH_PARAM, -5.f, 5.f, 0.f, "Pitch", " Hz", 2.f, dsp::FREQ_C4);
        configInput(VOCT_INPUT, "V/Oct");
        configOutput(AUDIO_OUTPUT, "Audio");
    }

    void process(const ProcessArgs& args) override {
        // Get channel count from primary input (0 if disconnected, but generate 1 channel)
        int channels = std::max(1, inputs[VOCT_INPUT].getChannels());

        // Process 4 channels at a time
        for (int c = 0; c < channels; c += 4) {
            // Get pitch with SIMD (polyphonic input spreads to all channels if mono)
            float_4 pitch = inputs[VOCT_INPUT].getPolyVoltageSimd<float_4>(c);
            pitch += params[PITCH_PARAM].getValue();

            // Convert pitch to frequency (exponential)
            float_4 freq = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch);

            // Accumulate phase
            float_4 deltaPhase = freq * args.sampleTime;
            phase[c/4] += deltaPhase;
            phase[c/4] -= simd::floor(phase[c/4]); // Wrap [0, 1)

            // Generate waveform
            float_4 output = simd::sin(2.f * M_PI * phase[c/4]);

            // Write 4 channels
            outputs[AUDIO_OUTPUT].setVoltageSimd(output * 5.f, c);
        }

        // Set output channel count
        outputs[AUDIO_OUTPUT].setChannels(channels);
    }
};
```

### Pattern 2: Panel Design with Component Layer
**What:** Inkscape SVG with components layer using specific RGB colors for helper.py
**When to use:** Every module (helper.py requirement)

**Setup:**
```
1. Document Properties > Units: millimeters
2. Create layer named "components"
3. Add circles/rectangles with exact RGB colors:
   - Parameters (knobs/switches): #ff0000 (red)
   - Inputs: #00ff00 (green)
   - Outputs: #0000ff (blue)
   - Lights: #ff00ff (magenta)
   - Custom widgets: #ffff00 (yellow)
4. Label each component in Object Properties (becomes C++ enum name)
5. Convert all text to paths (Path > Object to Path)
6. Hide components layer before saving
7. Run helper.py createmodule to generate code
```

**36 HP Panel Dimensions:**
- Width: 182.88mm (36 × 5.08mm)
- Height: 128.5mm (fixed Eurorack 3U)

### Pattern 3: Module Configuration in Constructor
**What:** Declare component counts and configure each param/input/output with labels
**When to use:** Every module constructor

**Example:**
```cpp
// Source: https://vcvrack.com/manual/PluginGuide
MyModule() {
    config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);

    // Parameters with range, default, label, unit, display scale
    configParam(FREQ_PARAM, -4.f, 4.f, 0.f, "Frequency", " Hz", 2.f, dsp::FREQ_C4);
    configParam(LEVEL_PARAM, 0.f, 1.f, 0.5f, "Level", "%", 0.f, 100.f);

    // Inputs/outputs with labels (tooltips auto-append "input"/"output")
    configInput(VOCT_INPUT, "V/Oct");
    configInput(GATE_INPUT, "Gate");
    configOutput(AUDIO_OUTPUT, "Audio");
    configOutput(MIX_OUTPUT, "Mix");

    // Optional: configure bypass routing for simple input->output effects
    // configBypass(AUDIO_INPUT, AUDIO_OUTPUT);
}
```

### Anti-Patterns to Avoid
- **Dynamic memory allocation in process():** Use fixed arrays or pre-allocated buffers. Malloc/new in audio thread causes glitches.
- **Static variables in Module:** Breaks multiple instances. Use member variables instead.
- **Uninitialized variables:** C++ doesn't zero-initialize. Always set `float phase = 0.f;` or use `{}`.
- **std::pow(2.f, pitch) for frequency conversion:** 10-100x slower than dsp::exp2_taylor5(), no quality benefit.
- **Forgetting setChannels():** Outputs default to 0 channels. Always call `outputs[X].setChannels(n)` after processing.
- **Text objects in SVG:** Rack's SVG renderer doesn't support fonts. Convert to paths or helper.py fails.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| V/Oct to frequency | `pow(2.0, pitch)` loop | `dsp::exp2_taylor5(pitch)` | 10-100x faster, 6e-06 max error (inaudible), SIMD compatible |
| Trigger detection | Voltage threshold check | `dsp::SchmittTrigger` | Proper hysteresis prevents noise-induced double triggers |
| Gate pulse generation | Manual timer + flag | `dsp::PulseGenerator` | Handles 1ms pulses correctly, tested edge cases |
| Smooth parameter changes | Linear interpolation | `dsp::ExponentialFilter` or `dsp::SlewLimiter` | Musical smoothing curves, rate-independent |
| Pitch constants | Hardcoded 261.626 Hz | `dsp::FREQ_C4`, `dsp::FREQ_A4` | Standard reference, audited for tuning accuracy |
| FFT operations | Custom DFT | `dsp::RealFFT` / `pffft` | Highly optimized, O(N log N), SIMD accelerated |
| Sample rate conversion | Naive decimation | `dsp::Decimator` / `dsp::Upsampler` | Proper antialiasing filters included |
| Antialiasing oscillators | Oversampling alone | `dsp::minBlepImpulse()` | MinBLEP is state-of-the-art for discontinuities (square/saw waves) |

**Key insight:** VCV's DSP library is heavily optimized and tested across thousands of patches. Custom implementations rarely match performance or correctness, and introduce maintenance burden. Use SDK primitives unless profiling proves a specific bottleneck.

## Common Pitfalls

### Pitfall 1: Incorrect Polyphonic Channel Handling
**What goes wrong:** Module processes wrong number of channels, causing silent outputs or crashes.

**Why it happens:**
- Unconnected inputs return `getChannels() == 0`, but module should still generate output
- Forgetting to call `outputs[X].setChannels(n)` leaves output at 0 channels (silent)
- Using input channel count directly without handling disconnected case

**How to avoid:**
```cpp
// Always ensure at least 1 channel of output
int channels = std::max(1, inputs[PRIMARY_INPUT].getChannels());

// If input is disconnected (0 channels), getPolyVoltage() returns 0V (safe)
float pitch = inputs[VOCT_INPUT].getPolyVoltage(c);

// ALWAYS set output channels after processing
outputs[AUDIO_OUTPUT].setChannels(channels);
```

**Warning signs:**
- Module is silent when input cable disconnected
- VCV shows 0 channels on output cable tooltip
- Crashes when channel count changes

### Pitfall 2: Filename Case Sensitivity Mismatches
**What goes wrong:** Plugin builds on Windows but fails to load on Mac/Linux.

**Why it happens:** Windows filesystem is case-insensitive, Mac/Linux are case-sensitive. Code references `mymodule.hpp` but file is `MyModule.hpp`.

**How to avoid:**
- Match exact case in #include directives: `#include "MyModule.hpp"` not `"mymodule.hpp"`
- Use consistent naming: PascalCase for files matching class names
- Test on Mac or Linux before release (or in case-sensitive volume)

**Warning signs:**
- "File not found" errors on Mac/Linux during compilation
- Windows developers report "works fine" but Mac users can't build

### Pitfall 3: Panel Text Not Converted to Paths
**What goes wrong:** helper.py fails with SVG parsing errors, or text doesn't appear in VCV Rack.

**Why it happens:** Rack's SVG renderer doesn't support text/font rendering. Helper.py requires geometric paths.

**How to avoid:**
1. Design panel with text objects in Inkscape
2. Select all text objects
3. Path > Object to Path (converts text to vector shapes)
4. Save SVG
5. Run helper.py

**Warning signs:**
- helper.py crashes with XML parsing errors
- Labels missing from panel in VCV Rack
- Font rendering warnings in log.txt

### Pitfall 4: Thread Safety Misunderstanding
**What goes wrong:** Developer adds mutexes unnecessarily, causing audio glitches and complexity.

**Why it happens:** Assumption that `process()` might be called from multiple threads simultaneously.

**How to avoid:** Understand VCV's threading model:
- Module methods (`process()`, `onReset()`, `dataToJson()`, etc.) are **mutually exclusive**
- VCV never calls module methods simultaneously from multiple threads
- **You typically don't need mutexes** in module code
- Mutexes in audio thread cause pops/clicks, strongly discouraged

**Warning signs:**
- Random audio glitches when module is active
- CPU spikes from lock contention
- Deadlocks when multiple modules interact

### Pitfall 5: Forgetting Sample Rate Independence
**What goes wrong:** Module sounds different or breaks at non-44.1kHz sample rates.

**Why it happens:** Hardcoding time constants or frequencies for 44100 Hz instead of using `args.sampleTime` or `args.sampleRate`.

**How to avoid:**
```cpp
void process(const ProcessArgs& args) override {
    // WRONG: phase += 440.0 / 44100.0;
    // RIGHT:
    float freq = 440.f;
    phase += freq * args.sampleTime; // args.sampleTime = 1.0 / sampleRate

    // For filters, use actual sample rate
    filter.setCutoff(1000.f / args.sampleRate);
}
```

**Warning signs:**
- Module sounds correct at 44.1kHz but wrong at 48kHz or 96kHz
- Timing-based features (LFO rates, envelope times) drift at different rates
- User reports "broken at high sample rates"

### Pitfall 6: Output Jack Visual Distinction
**What goes wrong:** Users can't quickly identify outputs vs inputs on panel.

**Why it happens:** Forgetting VCV panel design convention to visually distinguish outputs.

**How to avoid:**
- Use inverted/contrasting background for output jacks (darker or colored background)
- Inputs use same background as main panel (typically light grey)
- This is an established VCV convention users expect

**Warning signs:**
- User feedback: "hard to tell inputs from outputs"
- Panel looks cluttered or confusing
- Not following VCV visual standards

## Code Examples

Verified patterns from official sources:

### V/Oct Pitch to Frequency Conversion
```cpp
// Source: https://vcvrack.com/manual/VoltageStandards & https://vcvrack.com/manual/PluginGuide
// Standard V/Oct: 0V = C4 (261.6256 Hz), each 1V doubles frequency

// Get pitch voltage
float pitchCV = inputs[VOCT_INPUT].getVoltage();
float pitchParam = params[PITCH_PARAM].getValue(); // ±5 octaves

// Combine CV and parameter (additive in V/Oct)
float totalPitch = pitchCV + pitchParam;

// Convert to frequency (exponential)
float frequency = dsp::FREQ_C4 * dsp::exp2_taylor5(totalPitch);
// FREQ_C4 = 261.6256 Hz (MIDI note 60)
// exp2_taylor5 = fast 2^x approximation with <6e-06 error
```

### SIMD Polyphonic Processing Loop
```cpp
// Source: https://community.vcvrack.com/t/making-your-monophonic-module-polyphonic/6926
// Process up to 16 channels, 4 at a time with float_4

int channels = std::max(1, inputs[INPUT].getChannels());

// State for 16 channels (4 groups of 4)
float_4 phase[4] = {};

for (int c = 0; c < channels; c += 4) {
    // Load 4 channels at once (SIMD)
    float_4 pitch = inputs[VOCT_INPUT].getPolyVoltageSimd<float_4>(c);

    // Process with SIMD math functions
    float_4 freq = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch);
    float_4 deltaPhase = freq * args.sampleTime;

    // Accumulate phase
    phase[c/4] += deltaPhase;
    phase[c/4] -= simd::floor(phase[c/4]); // Wrap to [0, 1)

    // Generate output
    float_4 output = simd::sin(2.f * M_PI * phase[c/4]) * 5.f;

    // Store 4 channels
    outputs[OUTPUT].setVoltageSimd(output, c);
}

outputs[OUTPUT].setChannels(channels);
```

### Plugin Manifest (plugin.json)
```json
{
  "slug": "MyPlugin",
  "name": "My Plugin",
  "version": "2.0.0",
  "license": "GPL-3.0-or-later",
  "author": "Your Name",
  "brand": "My Brand",
  "authorEmail": "you@example.com",
  "authorUrl": "https://example.com",
  "pluginUrl": "https://example.com/myplugin",
  "manualUrl": "https://example.com/manual",
  "sourceUrl": "https://github.com/yourname/myplugin",
  "modules": [
    {
      "slug": "MyVCO",
      "name": "Dual VCO",
      "description": "8-voice polyphonic dual oscillator",
      "tags": ["Oscillator", "Polyphonic", "Dual"]
    }
  ]
}
```

### Trigger/Gate Detection with Schmitt Trigger
```cpp
// Source: https://vcvrack.com/docs-v2/namespacerack_1_1dsp
dsp::SchmittTrigger gateTrigger;

void process(const ProcessArgs& args) override {
    float gateVoltage = inputs[GATE_INPUT].getVoltage();

    // Returns true on rising edge (low->high transition)
    if (gateTrigger.process(gateVoltage, 0.1f, 2.f)) {
        // Trigger action (e.g., reset phase, start envelope)
        phase = 0.f;
    }
}
```

### Proper Parameter Smoothing
```cpp
// Source: https://vcvrack.com/docs-v2/namespacerack_1_1dsp
dsp::ExponentialFilter smoothParam;

MyModule() {
    config(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS, NUM_LIGHTS);
    // Lambda = time constant (~1/cutoff frequency)
    smoothParam.setLambda(100.f); // ~100 Hz smoothing
}

void process(const ProcessArgs& args) override {
    float rawParam = params[LEVEL_PARAM].getValue();
    float smoothed = smoothParam.process(args.sampleTime, rawParam);

    // Use smoothed value for audio processing
    output = input * smoothed;
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Scalar per-channel loops | SIMD float_4 processing | Rack v1.0 (2019) | ~4x CPU efficiency for polyphonic modules |
| Oversampling for antialiasing | MinBLEP/PolyBLEP | Fundamental v1.0 | Better quality, lower CPU, state-of-art oscillators |
| Manual JSON serialization | dataToJson/dataFromJson | Rack v1.0 | Type-safe, automatic version handling |
| Custom widget rendering | FramebufferWidget caching | Rack v1.0 | Huge GPU savings for complex displays |
| ParamWidget.paramQuantity member | getParamQuantity() method | Rack v2.0 (2021) | Fixes OpenGL context issues in DAW plugins |
| Text objects in SVG | Convert to paths | Rack v1.0+ | SVG renderer doesn't support fonts |
| Global config only | Per-project config | Rack v2.0+ | Enables workspace-specific settings |

**Deprecated/outdated:**
- **std::pow(2.f, pitch):** Replaced by `dsp::exp2_taylor5()` - 10-100x faster, no audible difference
- **Manual trigger detection:** Use `dsp::SchmittTrigger` instead - proper hysteresis prevents noise
- **Hardcoded 44100 Hz:** Always use `args.sampleRate` / `args.sampleTime` for rate independence
- **Static module variables:** Use member variables to support multiple instances
- **Manual polyphonic cable checking:** Use `getChannels()` and `getPolyVoltage()` / `getPolyVoltageSimd()`

## Open Questions

Things that couldn't be fully resolved:

1. **MinBLEP Implementation Details for VCO**
   - What we know: VCV Fundamental VCO-1/2 use MinBLEP for antialiasing (replaced oversampling). `dsp::minBlepImpulse()` generates impulse responses.
   - What's unclear: Exact implementation pattern for integrating MinBLEP into polyphonic sawtooth/square waveforms. How many samples in impulse response? How to handle SIMD processing with MinBLEP state?
   - Recommendation: Study Fundamental VCO source code (GPL-3.0, available on GitHub) or start with simpler waveforms (sine/triangle don't need antialiasing). MinBLEP is Phase 2 concern (oscillator DSP), not Phase 1.

2. **Optimal Panel Component Spacing**
   - What we know: "Design as if creating hardware", ensure thumbs fit between knobs and ports. 1 HP = 5.08mm.
   - What's unclear: Exact minimum spacing in mm for different component combinations (knob-to-knob, port-to-port, knob-to-port).
   - Recommendation: Follow existing VCV Fundamental modules as reference. Conservative spacing: ~10mm between knob edges, ~7mm between port centers. Test by adding modules to actual panel.

3. **Performance Benchmarks for 8-Voice Polyphony**
   - What we know: SIMD float_4 gives ~4x speedup vs scalar. Polyphonic modules are more efficient than multiple monophonic instances.
   - What's unclear: Exact CPU budget (as % of total) for dual VCO at 8 voices on reference hardware.
   - Recommendation: Profile during Phase 2 (oscillator DSP). Aim for <5% CPU on modern hardware. VCV has built-in CPU meter per module.

## Sources

### Primary (HIGH confidence)
- [VCV Rack Plugin Development Tutorial](https://vcvrack.com/manual/PluginDevelopmentTutorial) - Official SDK setup, helper.py usage, build process
- [VCV Rack Plugin API Guide](https://vcvrack.com/manual/PluginGuide) - Module class structure, polyphonic processing, SIMD patterns
- [VCV Rack Module Panel Guide](https://vcvrack.com/manual/Panel) - Panel dimensions, component layer colors, Inkscape workflow
- [VCV Rack Voltage Standards](https://vcvrack.com/manual/VoltageStandards) - Audio levels, V/Oct pitch, gate voltages, CV ranges
- [VCV Rack Plugin Manifest](https://vcvrack.com/manual/Manifest) - plugin.json structure and required fields
- [VCV Rack DSP Manual](https://vcvrack.com/manual/DSP) - DSP best practices, antialiasing, filter implementation
- [VCV Rack DSP API Reference](https://vcvrack.com/docs-v2/namespacerack_1_1dsp) - Complete dsp namespace documentation
- [VCV Rack v2 Migration Guide](https://vcvrack.com/manual/Migrate2) - SDK 2.x breaking changes and requirements

### Secondary (MEDIUM confidence)
- [Making Monophonic Modules Polyphonic - VCV Community](https://community.vcvrack.com/t/making-your-monophonic-module-polyphonic/6926) - SIMD implementation guide
- [Module Development Advice - VCV Community](https://community.vcvrack.com/t/could-someone-give-me-advice-on-developing-modules-for-vcv-rack/22000) - Best practices and pitfalls from experienced developers
- [VCV Rack Changelog](https://github.com/VCVRack/Rack/blob/v2/CHANGELOG.md) - SDK 2.6 features and changes
- [VCV Fundamental GitHub](https://github.com/VCVRack/Fundamental) - Reference implementation (note: no code contributions accepted)

### Tertiary (LOW confidence)
- Community forum discussions on panel design spacing - anecdotal, not authoritative
- MinBLEP implementation details - requires source code study for exact patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Official SDK documentation, well-established toolchain
- Architecture: HIGH - Official API guide provides canonical patterns, verified in Fundamental modules
- Pitfalls: HIGH - Documented in official guides, confirmed by community experience
- Panel design: HIGH - Exact specifications in official Panel Guide (HP to mm, color codes)
- Polyphonic SIMD: HIGH - Official Plugin Guide examples, community tutorial verification
- DSP utilities: HIGH - Complete API reference with descriptions and usage

**Research date:** 2026-01-22
**Valid until:** 2026-03-22 (60 days - VCV Rack SDK stable, infrequent breaking changes)

**Key constraints from CONTEXT.md:**
- 36 HP width (182.88mm) - locked decision
- Industrial/technical aesthetic, dark blue background - locked visual style
- VCO1 left, VCO2 right, global controls center - locked layout
- Pointer knobs, color-coded labels - locked UI choices
- Module name, font, exact colors - Claude's discretion within style

**Research aligns with phase boundary:** Development environment setup (SDK + helper.py), panel design (36 HP specs + Inkscape workflow), and polyphonic infrastructure (SIMD float_4 + V/Oct tracking). No oscillator DSP research included (that's Phase 2 scope).
