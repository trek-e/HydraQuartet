---
phase: 01-foundation-panel
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/HydraQuartetVCO.cpp
  - plugin.cpp
  - plugin.json
autonomous: false

must_haves:
  truths:
    - "User can send polyphonic V/Oct + Gate and see 8-channel polyphonic output"
    - "V/Oct tracking is accurate (C4 at 0V produces 261.6 Hz)"
    - "Mix output sums all voices to mono"
    - "Module loads in VCV Rack without errors"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "Module implementation with polyphonic I/O"
      exports: ["HydraQuartetVCO", "HydraQuartetVCOWidget"]
      min_lines: 80
    - path: "plugin.cpp"
      provides: "Module registration"
      contains: "addModel"
    - path: "plugin.json"
      provides: "Module manifest entry"
      contains: "HydraQuartetVCO"
  key_links:
    - from: "src/HydraQuartetVCO.cpp"
      to: "res/HydraQuartetVCO.svg"
      via: "setPanel() in widget"
      pattern: 'setPanel.*HydraQuartetVCO'
    - from: "src/HydraQuartetVCO.cpp"
      to: "plugin.cpp"
      via: "Model registration"
      pattern: "createModel.*HydraQuartetVCO"
    - from: "src/HydraQuartetVCO.cpp"
      to: "dsp::FREQ_C4"
      via: "V/Oct conversion"
      pattern: "FREQ_C4.*exp2"
---

<objective>
Implement the HydraQuartetVCO module with polyphonic infrastructure: 8-voice V/Oct tracking and audio output.

Purpose: Complete Phase 1 by delivering a functional module shell that can be loaded in VCV Rack with proper polyphonic I/O. No oscillator DSP yet - outputs simple sine wave to verify pitch tracking.

Output:
- Working HydraQuartetVCO module that loads in VCV Rack
- Polyphonic V/Oct input with accurate pitch tracking
- Polyphonic audio output (8-channel)
- Mono mix output (sum of all voices)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-panel/01-CONTEXT.md
@.planning/phases/01-foundation-panel/01-RESEARCH.md
@.planning/phases/01-foundation-panel/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate module code from panel SVG</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Run helper.py createmodule to generate module code from panel SVG:

```bash
$RACK_DIR/helper.py createmodule HydraQuartetVCO res/HydraQuartetVCO.svg src/HydraQuartetVCO.cpp
```

This will:
1. Parse component layer from SVG
2. Generate enum IDs for all params/inputs/outputs
3. Create Module class skeleton
4. Create Widget class with component positions from SVG

Verify the generated enums include at minimum:
- ParamIds: OCTAVE1_PARAM, TRI1_PARAM, SQR1_PARAM, etc.
- InputIds: VOCT_INPUT, GATE_INPUT, PWM1_INPUT, etc.
- OutputIds: AUDIO_OUTPUT, MIX_OUTPUT

If helper.py fails with SVG parsing errors, check:
- Components layer exists and has correct name "components"
- Each component has a name set in Object Properties
- Colors are exact: #ff0000, #00ff00, #0000ff
  </action>
  <verify>
- `ls src/HydraQuartetVCO.cpp` shows file exists
- File contains `enum ParamIds` with expected parameters
- File contains `enum InputIds` with VOCT_INPUT, GATE_INPUT
- File contains `enum OutputIds` with AUDIO_OUTPUT, MIX_OUTPUT
  </verify>
  <done>
Module code generated from panel SVG with all component enums
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement polyphonic processing</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Implement the process() method with polyphonic V/Oct tracking and audio output:

**Phase state (member variables):**
```cpp
// State for 16 channels (4 groups of 4 for SIMD)
float_4 phase[4] = {};
```

**Constructor configuration:**
```cpp
// Configure V/Oct and Gate inputs
configInput(VOCT_INPUT, "V/Oct");
configInput(GATE_INPUT, "Gate");

// Configure outputs
configOutput(AUDIO_OUTPUT, "Audio");
configOutput(MIX_OUTPUT, "Mix");

// Configure all param knobs (even if not functional yet)
// Use appropriate ranges and defaults for each
```

**process() implementation:**
```cpp
void process(const ProcessArgs& args) override {
    // Get channel count from V/Oct input (minimum 1)
    int channels = std::max(1, inputs[VOCT_INPUT].getChannels());

    // Mix accumulator for mono sum
    float mix = 0.f;

    // Process 4 channels at a time (SIMD)
    for (int c = 0; c < channels; c += 4) {
        // Get V/Oct pitch (polyphonic, spreads mono to all if mono source)
        float_4 pitch = inputs[VOCT_INPUT].getPolyVoltageSimd<float_4>(c);

        // Convert V/Oct to frequency
        // 0V = C4 (261.6256 Hz), 1V = C5, etc.
        float_4 freq = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch);

        // Accumulate phase
        float_4 deltaPhase = freq * args.sampleTime;
        phase[c/4] += deltaPhase;
        phase[c/4] -= simd::floor(phase[c/4]); // Wrap to [0, 1)

        // Generate simple sine wave (placeholder for real oscillator)
        // Phase 2 will add antialiased waveforms
        float_4 output = simd::sin(2.f * M_PI * phase[c/4]) * 5.f;

        // Write to polyphonic output
        outputs[AUDIO_OUTPUT].setVoltageSimd(output, c);

        // Accumulate to mix (sum all 4 channels in this SIMD block)
        mix += output[0] + output[1] + output[2] + output[3];
    }

    // Set output channel count (CRITICAL - forgetting causes silent output)
    outputs[AUDIO_OUTPUT].setChannels(channels);

    // Mix output: average of all voices (prevent clipping with many voices)
    outputs[MIX_OUTPUT].setVoltage(mix / channels);
}
```

**Important:**
- Use `dsp::FREQ_C4` and `dsp::exp2_taylor5()` - do NOT use std::pow
- Always call `setChannels()` on outputs
- Use `getPolyVoltageSimd<float_4>()` for SIMD processing
- Include required headers: `#include <cmath>` for M_PI

**DO NOT implement:**
- Waveform generation beyond simple sine (Phase 2)
- Antialiasing (Phase 2)
- Waveform mixing controls (Phase 2)
- PWM, FM, Sync features (later phases)

The goal is JUST polyphonic infrastructure with accurate V/Oct tracking.
  </action>
  <verify>
- `make` compiles without errors
- Code uses `dsp::FREQ_C4` and `dsp::exp2_taylor5()`
- Code calls `outputs[AUDIO_OUTPUT].setChannels()`
- Code processes up to 16 channels in SIMD blocks of 4
  </verify>
  <done>
Module implements 8-voice polyphonic processing with accurate V/Oct tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Register module and update manifest</name>
  <files>plugin.cpp, plugin.json</files>
  <action>
**Update plugin.cpp to register the module:**

Add model declaration (usually at top or in plugin.hpp):
```cpp
extern Model* modelHydraQuartetVCO;
```

In init() function, register the model:
```cpp
void init(Plugin* p) {
    pluginInstance = p;
    p->addModel(modelHydraQuartetVCO);
}
```

**In src/HydraQuartetVCO.cpp, define the model:**
```cpp
Model* modelHydraQuartetVCO = createModel<HydraQuartetVCO, HydraQuartetVCOWidget>("HydraQuartetVCO");
```

**Update plugin.json modules array:**
```json
"modules": [
  {
    "slug": "HydraQuartetVCO",
    "name": "HydraQuartet VCO",
    "description": "8-voice polyphonic dual oscillator with through-zero FM",
    "tags": ["Oscillator", "Polyphonic", "Dual"]
  }
]
```

Verify build completes and plugin.dylib (or .so/.dll) is created.
  </action>
  <verify>
- `make` completes without errors
- `ls plugin.dylib` (Mac) or `plugin.so` (Linux) or `plugin.dll` (Windows) exists
- `grep -q "HydraQuartetVCO" plugin.json` returns success
- `grep -q "addModel" plugin.cpp` returns success
  </verify>
  <done>
Module registered in plugin, manifest updated, plugin builds successfully
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 foundation: Plugin scaffold, 36 HP panel, and polyphonic module that loads in VCV Rack
  </what-built>
  <how-to-verify>
1. Copy the built plugin to VCV Rack plugins folder:
   - Mac: `~/Documents/Rack2/plugins/`
   - Windows: `%USERPROFILE%/Documents/Rack2/plugins/`
   - Linux: `~/.Rack2/plugins/`

2. Launch VCV Rack and add HydraQuartet VCO module (search "HydraQuartet" in module browser)

3. Verify panel appearance:
   - Module is 36 HP wide
   - VCO1 section on left, VCO2 on right, global in center
   - Dark industrial aesthetic
   - Outputs visually distinct from inputs
   - All controls present (even if not yet functional)

4. Test polyphonic V/Oct tracking:
   - Connect polyphonic MIDI-CV output to V/Oct input
   - Connect Audio output to audio output module
   - Play C4 (middle C) - should produce 261.6 Hz sine wave
   - Play C5 - should produce 523.2 Hz (one octave higher)
   - Play chord - should hear multiple voices

5. Test Mix output:
   - Connect Mix output to scope or audio output
   - Play polyphonic chord
   - Should see/hear mono sum of all voices

6. Check CPU usage:
   - Should be minimal (<1%) for simple sine waves
  </how-to-verify>
  <resume-signal>Type "approved" if module loads and V/Oct tracking works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Phase 1 complete when:
1. Module loads in VCV Rack without errors
2. Panel is 36 HP with proper layout (VCO1 left, VCO2 right, global center)
3. Outputs visually distinguished from inputs
4. V/Oct input accepts polyphonic cables (up to 8 voices)
5. C4 (0V) produces correct pitch (261.6 Hz)
6. Polyphonic audio output carries all voices
7. Mix output sums all voices to mono
</verification>

<success_criteria>
- Module compiles and loads in VCV Rack
- Panel matches CONTEXT.md visual decisions (dark industrial, 36 HP, mirrored VCO sections)
- V/Oct tracking accurate across range (verify C4 at 0V)
- 8-voice polyphony works via polyphonic cables
- Mix output produces mono sum
- Requirements satisfied: PANEL-01, PANEL-02, PANEL-03, FOUND-01, FOUND-02, CV-01, CV-02, OUT-01, OUT-02
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-panel/01-02-SUMMARY.md`
</output>
