---
phase: 04-dual-vco-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
autonomous: false

must_haves:
  truths:
    - "User can hear two distinct oscillators playing simultaneously"
    - "User can detune VCO1 to create beating/thickness effect against VCO2"
    - "User can shift VCO1 up or down by octaves"
    - "User can shift VCO2 up or down by octaves"
    - "User can mix VCO2 waveforms independently from VCO1"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "VcoEngine struct with dual instantiation"
      contains: "struct VcoEngine"
    - path: "src/HydraQuartetVCO.cpp"
      provides: "VCO1 and VCO2 engine instances"
      contains: "VcoEngine vco1"
    - path: "src/HydraQuartetVCO.cpp"
      provides: "Detune calculation for VCO1"
      contains: "detuneVolts"
  key_links:
    - from: "DETUNE1_PARAM"
      to: "freq1 calculation"
      via: "detuneVolts added to pitch"
      pattern: "pitch1.*octave1.*detune"
    - from: "TRI2_PARAM, SQR2_PARAM, SIN2_PARAM, SAW2_PARAM"
      to: "mixed output"
      via: "volume multiplication"
      pattern: "tri2.*triVol2.*sqr2.*sqrVol2"
    - from: "vco1.process() and vco2.process()"
      to: "per-voice output"
      via: "both engines called in SIMD loop"
      pattern: "vco1\\.process.*vco2\\.process"
---

<objective>
Extract VCO1 DSP into reusable VcoEngine struct, instantiate for both oscillators, and wire octave switches and detune control.

Purpose: Enable dual-oscillator sound design with independent pitch control per VCO, creating thickness and timbral complexity
Output: Working dual VCO with octave shifts and detune beating effect
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dual-vco-architecture/04-RESEARCH.md
@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract VcoEngine struct and instantiate dual oscillators</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Refactor the existing inline VCO1 DSP code into a reusable VcoEngine struct following the pattern from 04-RESEARCH.md:

1. Create VcoEngine struct BEFORE HydraQuartetVCO struct definition:
```cpp
struct VcoEngine {
    float_4 phase[4] = {};
    MinBlepBuffer<32> sawMinBlepBuffer[4];
    MinBlepBuffer<32> sqrMinBlepBuffer[4];
    float_4 triState[4] = {};

    void process(int g, float_4 freq, float sampleTime, float_4 pwm,
                 float_4& saw, float_4& sqr, float_4& tri, float_4& sine);
};
```

2. Move all per-oscillator DSP from process() into VcoEngine::process():
   - Phase accumulation and wrap detection
   - Sawtooth with MinBLEP
   - Square with PWM MinBLEP
   - Triangle via integration
   - Sine generation

3. Replace module members with engine instances:
   - Remove: `float_4 phase[4]`, `MinBlepBuffer<32> sawMinBlepBuffer[4]`, etc.
   - Add: `VcoEngine vco1;` and `VcoEngine vco2;` as module members

4. Update process() to call vco1.process() - do NOT wire vco2 yet in this task

IMPORTANT: Keep DC filters as module members (not in VcoEngine) - they operate on mixed output.

Verify the refactor compiles and sounds identical to Phase 3 before proceeding.
  </action>
  <verify>
`make -C /Users/trekkie/projects/vcvrack_modules/vco` compiles without errors. Load in VCV Rack and verify VCO1 produces identical sound to Phase 3 (same waveforms, same antialiasing quality).
  </verify>
  <done>
VcoEngine struct exists with process() method. VCO1 works via vco1.process() call. VCO2 instance exists but is not yet wired.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire pitch controls (octave + detune) and VCO2 output</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Wire the octave switches and detune control, then enable VCO2 output:

1. Read pitch control parameters ONCE outside the SIMD loop:
```cpp
float octave1 = std::round(params[OCTAVE1_PARAM].getValue());  // -2 to +2
float octave2 = std::round(params[OCTAVE2_PARAM].getValue());  // -2 to +2
float detuneKnob = params[DETUNE1_PARAM].getValue();           // 0 to 1
float detuneVolts = detuneKnob * (50.f / 1200.f);              // 0-50 cents
```

2. Read VCO2 volume parameters outside the loop:
```cpp
float triVol2 = params[TRI2_PARAM].getValue();
float sqrVol2 = params[SQR2_PARAM].getValue();
float sinVol2 = params[SIN2_PARAM].getValue();
float sawVol2 = params[SAW2_PARAM].getValue();
```

3. Read VCO2 PWM parameter:
```cpp
float pwm2 = params[PWM2_PARAM].getValue();
float_4 pwm2_4 = pwm2;
```

4. Inside the SIMD loop, calculate separate frequencies:
```cpp
float_4 basePitch = inputs[VOCT_INPUT].getPolyVoltageSimd<float_4>(c);

// VCO1: base + octave + detune
float_4 pitch1 = basePitch + octave1 + detuneVolts;
float_4 freq1 = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch1);
freq1 = simd::clamp(freq1, 0.1f, sampleRate / 2.f);

// VCO2: base + octave (reference, no detune)
float_4 pitch2 = basePitch + octave2;
float_4 freq2 = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch2);
freq2 = simd::clamp(freq2, 0.1f, sampleRate / 2.f);
```

5. Process both engines:
```cpp
float_4 saw1, sqr1, tri1, sine1;
float_4 saw2, sqr2, tri2, sine2;
vco1.process(g, freq1, sampleTime, pwm4, saw1, sqr1, tri1, sine1);
vco2.process(g, freq2, sampleTime, pwm2_4, saw2, sqr2, tri2, sine2);
```

6. Mix both VCOs:
```cpp
float_4 mixed = tri1 * triVol + sqr1 * sqrVol + sine1 * sinVol + saw1 * sawVol
              + tri2 * triVol2 + sqr2 * sqrVol2 + sine2 * sinVol2 + saw2 * sawVol2;
```

IMPORTANT: VCO1 gets detune, VCO2 is the reference (no detune). This ensures "0 detune = in tune".
  </action>
  <verify>
`make -C /Users/trekkie/projects/vcvrack_modules/vco` compiles. Load in VCV Rack:
1. Turn up both VCO1 and VCO2 volumes - hear two oscillators
2. Set detune to 0, same octave - oscillators in unison (no beating)
3. Increase detune - hear beating/thickness effect
4. Change VCO1 octave - hear pitch shift
5. Change VCO2 octave independently - hear pitch shift
  </verify>
  <done>
Both oscillators produce sound with independent volume control. Octave switches shift pitch by exact octaves. Detune creates beating effect at non-zero values. Zero detune means perfect unison with VCO2.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Dual VCO architecture with:
- VcoEngine struct extracted from VCO1 DSP
- Two independent oscillators (vco1, vco2)
- Octave switches for both VCOs (-2 to +2)
- Detune knob on VCO1 (0-50 cents)
- Independent volume controls for all 8 waveforms
  </what-built>
  <how-to-verify>
1. Build and load module: `make -C /Users/trekkie/projects/vcvrack_modules/vco && make -C /Users/trekkie/projects/vcvrack_modules/vco install`
2. Connect V/Oct from MIDI-CV or sequencer
3. Connect AUDIO output to audio device

Audio tests:
4. Turn VCO1 SAW to 1.0, VCO2 SAW to 0 - hear single saw wave
5. Turn VCO2 SAW to 1.0 - hear thicker sound (two saws)
6. Set DETUNE to 0 - oscillators should be in perfect unison (no beating)
7. Slowly increase DETUNE - hear beating effect increase, creating thickness
8. At max detune (~50 cents) - hear obvious chorusing/detuning
9. Set VCO1 OCTAVE to +1 - VCO1 jumps up one octave
10. Set VCO2 OCTAVE to -1 - VCO2 drops one octave (3 octaves apart now)
11. Mix different waveforms from VCO1 and VCO2 - verify independent control

CPU verification:
12. Check CPU usage with 8-voice polyphonic input - should be approximately 2x Phase 3 (1.5-2% expected)
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- [ ] VcoEngine struct exists and encapsulates all oscillator state
- [ ] vco1 and vco2 are separate instances with independent state
- [ ] Octave switches snap to integer values (-2, -1, 0, +1, +2)
- [ ] Detune at 0 = perfect unison (no beating)
- [ ] Detune at max = ~50 cents offset (clear beating)
- [ ] VCO2 volumes control VCO2 output independently
- [ ] CPU approximately 2x Phase 3 baseline (~1.6% expected)
- [ ] All waveforms antialiased (no harsh metallic sounds at high pitch)
</verification>

<success_criteria>
1. User can hear two oscillators playing simultaneously (16 total with 8-voice poly)
2. User can detune VCO1 to create thickness/beating effect against VCO2
3. User can shift VCO1 and VCO2 independently by octaves
4. User can mix waveforms from both VCOs independently
5. CPU usage is approximately 2x Phase 3 baseline (from 0.8% to ~1.6%)
</success_criteria>

<output>
After completion, create `.planning/phases/04-dual-vco-architecture/04-01-SUMMARY.md`
</output>
