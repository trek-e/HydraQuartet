---
phase: 02-core-oscillator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
autonomous: true

must_haves:
  truths:
    - "User can play sawtooth at >2kHz with no harsh metallic aliasing"
    - "User can play square wave with PWM sweep without clicks"
    - "User can hear triangle wave that sounds smooth, not buzzy"
    - "User can mix all 4 waveforms using VCO1 volume knobs"
    - "Oscillator runs stable for 10+ minutes without drift"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "Antialiased polyphonic VCO1 with 4 waveforms"
      contains: "MinBlepGenerator"
  key_links:
    - from: "phase accumulator wrap"
      to: "sawMinBlep.insertDiscontinuity()"
      via: "subsample calculation"
      pattern: "subsample.*-.*1\\.f"
    - from: "phase crossing pulseWidth"
      to: "sqrMinBlep.insertDiscontinuity()"
      via: "phasePrev < pulseWidth && phase >= pulseWidth"
      pattern: "phasePrev.*<.*pulseWidth.*&&.*phase.*>=.*pulseWidth"
    - from: "antialiased square"
      to: "triangle integrator"
      via: "leaky integration"
      pattern: "triState.*\\*.*0\\.999"
    - from: "TRI1_PARAM, SQR1_PARAM, SIN1_PARAM, SAW1_PARAM"
      to: "mixed output"
      via: "volume multiplication and sum"
      pattern: "tri.*triVol.*\\+.*sqr.*sqrVol"
---

<objective>
Implement VCO1 with four antialiased waveforms (triangle, square, sine, sawtooth) using MinBLEP correction.

Purpose: This phase establishes the core oscillator quality that defines the module. Antialiasing cannot be retrofitted - getting it right now prevents months of bug hunting later. The sawtooth and square use MinBLEP, triangle integrates the antialiased square, and sine needs no correction.

Output: Working polyphonic VCO1 with all 4 waveform volume knobs functional, clean audio at any pitch.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-oscillator/02-RESEARCH.md

@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-voice MinBLEP and DC filter state</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Add per-voice state structures to HydraQuartetVCO class for antialiasing.

**Add includes if not present:**
- No additional includes needed (MinBlepGenerator is in dsp namespace, already available via plugin.hpp)

**Add per-voice state struct BEFORE the HydraQuartetVCO struct:**
```cpp
struct VCO1Voice {
    dsp::MinBlepGenerator<16, 16, float> sawMinBlep;
    dsp::MinBlepGenerator<16, 16, float> sqrMinBlep;
    dsp::TRCFilter<float> dcFilter;
    float dcFilterState = 0.f;
    float triState = 0.f;  // Integrator state for triangle
};
```

**Add member variable to HydraQuartetVCO (after the phase[4] array):**
```cpp
VCO1Voice vco1Voices[16];  // Per-voice state for 16 channels
```

**Why 16 voices:** VCV Rack supports up to 16 polyphonic channels. Using an array of 16 ensures we handle the maximum case.

**Why separate MinBLEP for saw and square:** Each waveform has independent discontinuities. Sharing would cause incorrect corrections.
  </action>
  <verify>
Run `make` - code should compile without errors. The new structs are not yet used in process().
  </verify>
  <done>
VCO1Voice struct defined with MinBLEP generators, DC filter, and triangle integrator state. Array of 16 voices added to module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement antialiased waveform generation</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Replace the current simple sine generation in process() with full antialiased waveform generation.

**Modify the per-voice loop to process scalar (not SIMD) for MinBLEP compatibility:**

The current code processes 4 channels at a time with SIMD. MinBLEP is per-voice scalar, so change the loop structure. Keep SIMD pitch calculation but process waveforms per-voice.

**Inside process(), REPLACE the existing for-loop with:**

```cpp
// Read VCO1 parameters (outside loop - same for all voices)
float pwm1 = params[PWM1_PARAM].getValue();  // 0-1, 0.5 = 50% duty
float sampleTime = args.sampleTime;
float sampleRate = args.sampleRate;

// Mix accumulator for mono sum
float mix = 0.f;

// Process each voice individually (MinBLEP is per-voice)
for (int c = 0; c < channels; c++) {
    // Get V/Oct pitch for this voice
    float pitch = inputs[VOCT_INPUT].getVoltage(c);

    // Convert V/Oct to frequency (0V = C4 = 261.6 Hz)
    float freq = dsp::FREQ_C4 * dsp::exp2_taylor5(pitch);

    // Clamp frequency to safe range (prevent numerical issues)
    freq = clamp(freq, 0.1f, sampleRate / 2.f);

    // Get per-voice state
    VCO1Voice& voice = vco1Voices[c];

    // Update phase
    float deltaPhase = freq * sampleTime;
    float phasePrev = phase[c / 4][c % 4];  // Read current phase
    float phaseNow = phasePrev + deltaPhase;

    // === SAWTOOTH with MinBLEP ===
    // Detect discontinuity at phase wrap (1.0 -> 0.0)
    if (phaseNow >= 1.f) {
        phaseNow -= 1.f;
        float subsample = phaseNow / deltaPhase;
        // Sawtooth drops from +1 to -1, magnitude -2
        voice.sawMinBlep.insertDiscontinuity(subsample - 1.f, -2.f);
    }

    // Generate naive sawtooth [-1, +1]
    float saw = 2.f * phaseNow - 1.f;
    saw += voice.sawMinBlep.process();

    // === SQUARE with MinBLEP ===
    // Rising edge at phase 0 (already handled by saw wrap detection)
    // Use same wrap detection but different MinBLEP
    if (phasePrev + deltaPhase >= 1.f && phasePrev < 1.f) {
        float subsample = phaseNow / deltaPhase;
        voice.sqrMinBlep.insertDiscontinuity(subsample - 1.f, 2.f);  // -1 to +1
    }

    // Falling edge at pulse width threshold
    // CRITICAL: Only insert when phase CROSSES, not when parameter changes
    if (phasePrev < pwm1 && phaseNow >= pwm1) {
        float subsample = (pwm1 - phasePrev) / deltaPhase;
        voice.sqrMinBlep.insertDiscontinuity(subsample - 1.f, -2.f);  // +1 to -1
    }

    // Generate naive square
    float sqr = (phaseNow < pwm1) ? 1.f : -1.f;
    sqr += voice.sqrMinBlep.process();

    // === TRIANGLE via integration ===
    // Integrate antialiased square with leaky integrator
    // Scale by 4 * freq to normalize amplitude
    voice.triState = voice.triState * 0.999f + sqr * 4.f * freq * sampleTime;
    float tri = voice.triState;

    // === SINE (no antialiasing needed) ===
    float sine = std::sin(2.f * M_PI * phaseNow);

    // === DC FILTERING ===
    // Apply DC blocking highpass (10 Hz cutoff)
    voice.dcFilter.setCutoffFreq(10.f / sampleRate);
    saw = voice.dcFilter.process(voice.dcFilterState, saw);

    // Store updated phase back
    phase[c / 4][c % 4] = phaseNow;

    // Store waveforms for mixing in Task 3 (temporary: output sine only for now)
    float output = sine * 5.f;

    outputs[AUDIO_OUTPUT].setVoltage(output, c);
    mix += output;
}

// Set output channel count
outputs[AUDIO_OUTPUT].setChannels(channels);

// Mix output: average of all voices
outputs[MIX_OUTPUT].setVoltage(mix / channels);
```

**Important implementation notes:**
1. Phase is stored in float_4 arrays but accessed per-voice via `phase[c/4][c%4]`
2. The rising edge detection for square happens at phase wrap (same as saw)
3. Falling edge detection uses `phasePrev < pwm1 && phaseNow >= pwm1` to avoid VCV Fundamental bug
4. Triangle uses 0.999 decay factor (leaky integrator prevents DC drift)
5. DC filter applied to saw (the noisiest for DC offset)
  </action>
  <verify>
1. Run `make` - should compile without errors
2. Load module in VCV Rack
3. Connect V/Oct and play notes - should hear sine output (mixing not connected yet)
4. No crashes when playing polyphonic input
  </verify>
  <done>
All 4 waveforms generated with antialiasing: sawtooth uses MinBLEP, square uses MinBLEP with proper edge detection, triangle integrates square, sine is native. DC filtering applied.
  </done>
</task>

<task type="auto">
  <name>Task 3: Connect VCO1 volume knobs and mix waveforms</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Replace the temporary sine-only output with proper waveform mixing using all 4 VCO1 volume knobs.

**In process(), read volume parameters OUTSIDE the loop (after PWM read):**
```cpp
float triVol = params[TRI1_PARAM].getValue();
float sqrVol = params[SQR1_PARAM].getValue();
float sinVol = params[SIN1_PARAM].getValue();
float sawVol = params[SAW1_PARAM].getValue();
```

**REPLACE the temporary output line with proper mixing:**

Remove:
```cpp
float output = sine * 5.f;
```

Replace with:
```cpp
// Mix all 4 waveforms with volume controls
// Each waveform is [-1, +1], scale to [-5V, +5V] after mixing
float mixed = tri * triVol + sqr * sqrVol + sine * sinVol + saw * sawVol;

// Scale to VCV Rack audio level (5V peak)
float output = mixed * 5.f;
```

**Also apply DC filtering to the mixed output (move DC filter to after mixing):**

The current implementation filters only saw. Move the filter to after mixing for cleaner output:

```cpp
// DC blocking on final mixed output
voice.dcFilter.setCutoffFreq(10.f / sampleRate);
float output = voice.dcFilter.process(voice.dcFilterState, mixed * 5.f);
```

**Remove the redundant DC filter call on saw alone.**

**Final output section should be:**
```cpp
// Mix all 4 waveforms
float mixed = tri * triVol + sqr * sqrVol + sine * sinVol + saw * sawVol;

// DC blocking on final mixed output (10 Hz highpass)
voice.dcFilter.setCutoffFreq(10.f / sampleRate);
float output = voice.dcFilter.process(voice.dcFilterState, mixed * 5.f);

outputs[AUDIO_OUTPUT].setVoltage(output, c);
mix += output;
```
  </action>
  <verify>
1. Run `make` - should compile
2. Load module in VCV Rack
3. Connect V/Oct, play notes
4. Turn TRI1 knob up - should hear triangle wave
5. Turn SQR1 knob up - should hear square wave
6. Turn SIN1 knob up - should hear sine wave (was already working)
7. Turn SAW1 knob up - should hear sawtooth wave
8. All 4 knobs at 0.5 - should hear mixed waveforms
9. Play high pitch (>2kHz) saw - should NOT sound harsh/metallic (antialiasing working)
10. Sweep PWM1 knob slowly while playing square - should NOT click (avoiding VCV bug)
  </verify>
  <done>
All 4 VCO1 waveform volume knobs (TRI1, SQR1, SIN1, SAW1) connected. User can mix waveforms and adjust individual volumes. Antialiased output verified.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Antialiasing Quality Test:**
   - Connect BOGAUDIO ANALYZER to output
   - Play high C (C7 ~2093 Hz) sawtooth
   - Spectrum should show harmonics rolling off cleanly, no aliasing foldback above Nyquist/2
   - Compare to VCV Fundamental VCO at same pitch - should be similar quality

2. **PWM Stability Test:**
   - Play sustained square wave note
   - Slowly sweep PWM1 knob from 0.1 to 0.9
   - Should NOT hear clicks or pops (VCV Fundamental bug avoided)

3. **Long-Term Stability Test:**
   - Play sustained note for 10+ minutes
   - Pitch should not drift (phase accumulator stable)
   - Use tuner module to verify

4. **Polyphony Test:**
   - Send 8-voice polyphonic chord
   - All 8 voices should sound correct
   - CPU usage should be reasonable (<5%)
</verification>

<success_criteria>
- [ ] Module compiles without errors
- [ ] All 4 waveforms audible via their volume knobs
- [ ] Sawtooth at >2kHz sounds clean (no metallic aliasing)
- [ ] Square with PWM sweep has no clicks
- [ ] Triangle sounds smooth (not buzzy at high pitch)
- [ ] 8-voice polyphony works correctly
- [ ] No DC offset visible on oscilloscope module
- [ ] Oscillator stable over 10+ minutes
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-oscillator/02-01-SUMMARY.md` using the summary template.
</output>
