---
phase: 03-simd-polyphony
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/TriaxVCO.cpp
autonomous: false

must_haves:
  truths:
    - "User can play 8-note polyphonic chord with acceptable CPU usage (<5% baseline)"
    - "Polyphonic patch behavior matches Phase 2 monophonic (no audio artifacts)"
    - "Developer can measure 3-4x CPU improvement vs Phase 2 scalar implementation"
  artifacts:
    - path: "src/TriaxVCO.cpp"
      provides: "SIMD-optimized VCO1 engine with float_4 processing"
      contains: "float_4"
    - path: "src/TriaxVCO.cpp"
      provides: "Strided MinBLEP buffer for SIMD-compatible antialiasing"
      contains: "MinBlepBuffer"
  key_links:
    - from: "MinBlepBuffer"
      to: "minBlep.insertDiscontinuity"
      via: "stride=4 parameter"
      pattern: "insertDiscontinuity.*stride"
    - from: "process()"
      to: "inputs[VOCT_INPUT]"
      via: "getPolyVoltageSimd<float_4>"
      pattern: "getPolyVoltageSimd"
    - from: "waveform generation"
      to: "phase comparisons"
      via: "simd::ifelse branchless conditionals"
      pattern: "simd::ifelse"
---

<objective>
Convert VCO1 from scalar per-voice processing to SIMD float_4 processing for 3-4x CPU efficiency improvement.

Purpose: With 16 oscillators total (2 VCOs x 8 voices), SIMD optimization is mandatory for acceptable CPU usage. This phase templates the oscillator core for float_4 before Phase 4 doubles the oscillator count.

Output: src/TriaxVCO.cpp with templated SIMD engine processing 4 voices per iteration while maintaining MinBLEP antialiasing quality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-simd-polyphony/03-RESEARCH.md
@src/TriaxVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MinBlepBuffer and SIMD Loop Structure</name>
  <files>src/TriaxVCO.cpp</files>
  <action>
Replace the scalar VCO1Voice struct and per-voice loop with SIMD-compatible infrastructure:

1. Add MinBlepBuffer template struct (from 03-RESEARCH.md Pattern 3):
   ```cpp
   template <int N, typename T>
   struct MinBlepBuffer {
       T buffer[2 * N] = {};
       int bufferIndex = 0;

       T shift() {
           T v = buffer[bufferIndex++];
           if (bufferIndex >= N) {
               std::memcpy(buffer, buffer + N, N * sizeof(T));
               std::memset(buffer + N, 0, N * sizeof(T));
               bufferIndex = 0;
           }
           return v;
       }

       float* startData() { return (float*)buffer + bufferIndex * 4; }
   };
   ```

2. Replace VCO1Voice struct with SIMD voice group arrays:
   - `MinBlepBuffer<32, float_4> sawMinBlepBuffer[4]` - one per SIMD group (4 groups x 4 voices = 16 max)
   - `MinBlepBuffer<32, float_4> sqrMinBlepBuffer[4]` - one per SIMD group
   - `float_4 triState[4]` - triangle integrator state per SIMD group
   - `dsp::TRCFilter<float> dcFilters[16]` - keep DC filters scalar (not in hot path)
   - Remove the old `VCO1Voice vco1Voices[16]` array

3. Convert process() loop to SIMD groups:
   - Change `for (int c = 0; c < channels; c++)` to `for (int c = 0; c < channels; c += 4)`
   - Inside loop: `int groupChannels = std::min(channels - c, 4)`
   - Use `inputs[VOCT_INPUT].getPolyVoltageSimd<float_4>(c)` for pitch
   - Use `outputs[AUDIO_OUTPUT].setVoltageSimd(output, c)` for output

4. Add static minBlep generator for stride insertions:
   ```cpp
   static dsp::MinBlepGenerator<16, 16, float> minBlep;
   ```
   This is the lookup table, not per-voice state.

CRITICAL: Do NOT implement waveform generation yet - just set up the loop structure returning silence or naive saw. Task 2 adds the full waveform logic.

AVOID: Per-element access `phase[i]` except inside movemask conditional blocks.
  </action>
  <verify>
`make` compiles successfully. Module loads in VCV Rack without crash. Output may be silent or simple saw (waveform logic comes in Task 2).
  </verify>
  <done>
MinBlepBuffer struct exists. Process loop iterates in groups of 4 with getPolyVoltageSimd/setVoltageSimd. Old VCO1Voice array removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SIMD Waveforms with MinBLEP</name>
  <files>src/TriaxVCO.cpp</files>
  <action>
Implement full waveform generation inside the SIMD loop:

1. Phase accumulation with SIMD (from 03-RESEARCH.md):
   ```cpp
   float_4 deltaPhase = simd::clamp(freq * sampleTime, 0.f, 0.49f);
   float_4 oldPhase = phase[c / 4];
   phase[c / 4] += deltaPhase;

   // Detect wrap
   float_4 wrapped = phase[c / 4] >= 1.f;
   phase[c / 4] -= simd::floor(phase[c / 4]);  // Handles large FM jumps
   ```

2. Sawtooth with strided MinBLEP insertion:
   ```cpp
   // Insert MinBLEP for wrapped lanes only
   int wrapMask = simd::movemask(wrapped);
   if (wrapMask) {
       for (int i = 0; i < 4; i++) {
           if (wrapMask & (1 << i)) {
               float subsample = (1.f - oldPhase[i]) / deltaPhase[i] - 1.f;
               float* x = sawMinBlepBuffer[c / 4].startData();
               minBlep.insertDiscontinuity(subsample, -2.f, &x[i], 4);  // stride=4
           }
       }
   }
   float_4 saw = 2.f * phase[c / 4] - 1.f + sawMinBlepBuffer[c / 4].shift();
   ```

3. Square with PWM using simd::ifelse (CRITICAL: avoid VCV Fundamental click bug):
   ```cpp
   float_4 pwm4 = pwm1;  // Broadcast scalar to SIMD

   // Rising edge detection (phase wrap)
   // Already handled above in wrapMask

   // Falling edge detection (phase crosses PWM threshold)
   float_4 fallingEdge = (oldPhase < pwm4) & (phase[c / 4] >= pwm4);
   int fallMask = simd::movemask(fallingEdge);
   if (fallMask) {
       for (int i = 0; i < 4; i++) {
           if (fallMask & (1 << i)) {
               float subsample = (pwm4[i] - oldPhase[i]) / deltaPhase[i] - 1.f;
               float* x = sqrMinBlepBuffer[c / 4].startData();
               minBlep.insertDiscontinuity(subsample, -2.f, &x[i], 4);
           }
       }
   }

   // Rising edge on wrap
   if (wrapMask) {
       for (int i = 0; i < 4; i++) {
           if (wrapMask & (1 << i)) {
               float subsample = (1.f - oldPhase[i]) / deltaPhase[i] - 1.f;
               float* x = sqrMinBlepBuffer[c / 4].startData();
               minBlep.insertDiscontinuity(subsample, 2.f, &x[i], 4);
           }
       }
   }

   float_4 sqr = simd::ifelse(phase[c / 4] < pwm4, 1.f, -1.f) + sqrMinBlepBuffer[c / 4].shift();
   ```

4. Triangle via integration (keep leaky integrator approach):
   ```cpp
   triState[c / 4] = triState[c / 4] * 0.999f + sqr * 4.f * freq * sampleTime;
   float_4 tri = triState[c / 4];
   ```

5. Sine (no antialiasing needed):
   ```cpp
   float_4 sine = simd::sin(2.f * M_PI * phase[c / 4]);
   ```

6. Mix and output:
   ```cpp
   float_4 mixed = tri * triVol + sqr * sqrVol + sine * sinVol + saw * sawVol;

   // DC filtering - process per-voice (not in critical path)
   for (int i = 0; i < groupChannels; i++) {
       dcFilters[c + i].setCutoffFreq(10.f / sampleRate);
       dcFilters[c + i].process(mixed[i] * 5.f);
       mixed[i] = dcFilters[c + i].highpass();
   }

   outputs[AUDIO_OUTPUT].setVoltageSimd(mixed, c);
   ```

7. Update mix accumulator (use horizontal sum for efficiency):
   ```cpp
   // After loop ends:
   float_4 mixSum = 0.f;
   for (int g = 0; g < (channels + 3) / 4; g++) {
       mixSum += outputs[AUDIO_OUTPUT].getVoltageSimd<float_4>(g * 4);
   }
   mixSum.v = _mm_hadd_ps(mixSum.v, mixSum.v);
   mixSum.v = _mm_hadd_ps(mixSum.v, mixSum.v);
   outputs[MIX_OUTPUT].setVoltage(mixSum[0] / channels);
   ```

AVOID: Branching on SIMD values outside movemask blocks. Use simd::ifelse for all conditionals.
  </action>
  <verify>
1. `make` compiles successfully
2. Module loads in VCV Rack
3. Connect polyphonic MIDI-CV to V/Oct, play 8-note chord
4. All 4 waveforms sound correct (no clicks, no aliasing)
5. Verify with VCV Scope that output is polyphonic (8 channels)
  </verify>
  <done>
All 4 VCO1 waveforms (saw, square, triangle, sine) working with SIMD float_4 processing. MinBLEP antialiasing maintained via stride-4 insertions. No audible difference from Phase 2 scalar implementation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>SIMD-optimized VCO1 engine processing 4 voices per iteration with MinBLEP antialiasing</what-built>
  <how-to-verify>
1. Open VCV Rack with TriaxVCO module
2. Connect polyphonic MIDI-CV (or similar) to V/Oct input
3. Play an 8-note chord (all 8 voices active)
4. Check CPU meter in VCV Rack (View > Engine > CPU meter)
5. Compare to Phase 2 baseline:
   - Phase 2 scalar: [user to measure before SIMD changes]
   - Phase 3 SIMD: should be 3-4x lower
   - Target: <5% CPU at 8 voices

6. Audio quality check:
   - Sweep SAW1 volume: sawtooth should sound clean at high frequencies
   - Sweep PWM1 knob: no clicks during sweep
   - Enable TRI1: smooth triangle, no buzz
   - Enable SIN1: clean sine

7. Polyphony check:
   - Connect VCV Scope to AUDIO output
   - Verify 8 distinct waveforms visible
   - Each voice should track its V/Oct correctly
  </how-to-verify>
  <resume-signal>Type "approved" if CPU is 3-4x improved and audio quality matches Phase 2. Otherwise describe issues.</resume-signal>
</task>

</tasks>

<verification>
- [ ] Module compiles without warnings
- [ ] 8-voice polyphony works without CPU spike
- [ ] Sawtooth clean at high frequencies (MinBLEP working)
- [ ] PWM sweep click-free (edge detection correct)
- [ ] Triangle smooth (integrator stable)
- [ ] CPU usage <5% at 8 voices (SIMD benefit realized)
- [ ] CPU improvement is 3-4x vs Phase 2 scalar baseline
</verification>

<success_criteria>
1. User can play 8-note polyphonic chord with <5% baseline CPU
2. Developer can verify float_4 SIMD processing in code (grep for float_4, getPolyVoltageSimd)
3. Audio quality matches Phase 2 exactly (no artifacts, clicks, or aliasing)
4. Developer can measure 3-4x CPU improvement by comparing to Phase 2 measurement
</success_criteria>

<output>
After completion, create `.planning/phases/03-simd-polyphony/03-01-SUMMARY.md`
</output>
