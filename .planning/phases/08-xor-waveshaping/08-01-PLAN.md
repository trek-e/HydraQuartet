---
phase: 08-xor-waveshaping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
autonomous: true

must_haves:
  truths:
    - "XOR output produces ring modulation of VCO1 and VCO2 square waves"
    - "XOR transitions are MinBLEP antialiased when either oscillator transitions"
    - "PWM changes on both VCOs affect XOR waveform character"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "XOR ring modulation DSP with MinBLEP antialiasing"
      contains: "xorMinBlepBuffer"
  key_links:
    - from: "VcoEngine::process()"
      to: "xorMinBlepBuffer"
      via: "XOR edge tracking on wrap and PWM fall"
      pattern: "xorMinBlepBuffer.*insertDiscontinuity"
    - from: "main process loop"
      to: "VCO2 xor output"
      via: "passing sqr1 to VCO2"
      pattern: "sqr1.*sqr2|sqr2.*sqr1"
---

<objective>
Implement XOR ring modulation output via square wave multiplication (sqr1 * sqr2) with full MinBLEP antialiasing.

Purpose: XOR output provides unique harmonic content by combining pulse waves from both VCOs. When both VCOs are at the same pitch, XOR produces a DC-coupled waveform; when detuned, it creates ring modulation timbres.

Output: VcoEngine with xorMinBlepBuffer and XOR output capability, tracking edges from both oscillators.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-xor-waveshaping/08-CONTEXT.md
@.planning/phases/08-xor-waveshaping/08-RESEARCH.md
@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add xorMinBlepBuffer and modify VcoEngine signature</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Add xorMinBlepBuffer to VcoEngine struct:
```cpp
MinBlepBuffer<32> xorMinBlepBuffer[4];  // XOR discontinuity tracking
```

Modify VcoEngine::process() signature to accept sqr1 input and optional XOR output pointer:
```cpp
void process(int g, float_4 freq, float sampleTime, float_4 pwm,
             float_4& saw, float_4& sqr, float_4& tri, float_4& sine,
             int& wrapMask,
             float_4 sqr1Input = float_4(0.f),  // Square from VCO1 (for XOR)
             float_4* xorOut = nullptr)          // Optional XOR output
```

The sqr1Input parameter defaults to 0 (unused for VCO1), and xorOut is nullptr for VCO1 (no XOR calculation).
  </action>
  <verify>Code compiles: `cd /Users/trekkie/projects/vcvrack_modules/vco && make clean && make`</verify>
  <done>VcoEngine has xorMinBlepBuffer array and process() accepts sqr1Input and xorOut parameters</done>
</task>

<task type="auto">
  <name>Task 2: Implement XOR calculation with MinBLEP tracking</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Inside VcoEngine::process(), after the square wave calculation, add XOR generation when xorOut is not nullptr:

```cpp
// XOR ring modulation (only if requested)
if (xorOut != nullptr) {
    // Raw ring modulation: sqr1 * sqr2
    *xorOut = sqr1Input * sqr;

    // Track XOR edges from THIS oscillator's square transitions
    // (sqr1Input edges are tracked separately in VCO1's call)

    // Falling edge detection (PWM threshold crossing)
    // When sqr transitions from +1 to -1, XOR changes by -2 * sqr1Input
    if (fallMask) {
        for (int i = 0; i < 4; i++) {
            if ((fallMask & (1 << i)) && deltaPhase[g][i] > 0.f) {
                float subsample = (pwm[i] - oldPhase[g][i]) / deltaPhase[g][i] - 1.f;
                float xorDisc = -2.f * sqr1Input[i];  // sqr: +1 -> -1
                xorMinBlepBuffer[g].insertDiscontinuity(subsample, xorDisc, i);
            }
        }
    }

    // Rising edge on wrap (when phase wraps, sqr goes from -1 to +1)
    if (wrapMask) {
        for (int i = 0; i < 4; i++) {
            if ((wrapMask & (1 << i)) && deltaPhase[g][i] > 0.f) {
                float subsample = (1.f - oldPhase[g][i]) / deltaPhase[g][i] - 1.f;
                float xorDisc = 2.f * sqr1Input[i];  // sqr: -1 -> +1
                xorMinBlepBuffer[g].insertDiscontinuity(subsample, xorDisc, i);
            }
        }
    }

    // Apply MinBLEP correction
    *xorOut += xorMinBlepBuffer[g].process();
}
```

Key insight: XOR discontinuity magnitude is 2 * sqr1Input because the local sqr changes by 2 (from +1 to -1 or -1 to +1), and XOR = sqr1Input * sqr.
  </action>
  <verify>Code compiles: `cd /Users/trekkie/projects/vcvrack_modules/vco && make`</verify>
  <done>VcoEngine::process() calculates XOR with MinBLEP antialiasing when xorOut is provided</done>
</task>

<task type="auto">
  <name>Task 3: Track XOR edges from VCO1 in main process loop</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
The XOR output also needs MinBLEP tracking for when VCO1's square wave transitions (not just VCO2's).

Add xorMinBlepBuffer to module scope (not inside VcoEngine) for tracking VCO1 edges:
```cpp
// In HydraQuartetVCO struct:
MinBlepBuffer<32> xorFromVco1MinBlep[4];  // Track VCO1 sqr transitions for XOR
```

In the main process loop, after VCO1 processes but before VCO2, track VCO1 edges for XOR:

```cpp
// Track VCO1 square edges for XOR MinBLEP (XOR = sqr1 * sqr2)
// When sqr1 transitions, XOR changes by 2 * sqr2

// VCO1 rising edge (wrap)
if (vco1WrapMask) {
    for (int i = 0; i < 4; i++) {
        if ((vco1WrapMask & (1 << i)) && vco1.deltaPhase[g][i] > 0.f) {
            float subsample = (1.f - vco1.oldPhase[g][i]) / vco1.deltaPhase[g][i] - 1.f;
            // sqr1: -1 -> +1, so XOR changes by 2 * sqr2
            float xorDisc = 2.f * sqr2[i];
            xorFromVco1MinBlep[g].insertDiscontinuity(subsample, xorDisc, i);
        }
    }
}

// VCO1 falling edge (PWM threshold)
float_4 vco1FallingEdge = (vco1.oldPhase[g] < pwm1_4) & (vco1.phase[g] >= pwm1_4);
int vco1FallMask = simd::movemask(vco1FallingEdge);
if (vco1FallMask) {
    for (int i = 0; i < 4; i++) {
        if ((vco1FallMask & (1 << i)) && vco1.deltaPhase[g][i] > 0.f) {
            float subsample = (pwm1_4[i] - vco1.oldPhase[g][i]) / vco1.deltaPhase[g][i] - 1.f;
            // sqr1: +1 -> -1, so XOR changes by -2 * sqr2
            float xorDisc = -2.f * sqr2[i];
            xorFromVco1MinBlep[g].insertDiscontinuity(subsample, xorDisc, i);
        }
    }
}
```

Note: This tracking happens AFTER vco2.process() so we have sqr2 values to use.

Update the XOR calculation to combine both MinBLEP buffers:
```cpp
float_4 xor = sqr1 * sqr2;
xor += vco2.xorMinBlepBuffer[g].process();  // VCO2 edges
xor += xorFromVco1MinBlep[g].process();      // VCO1 edges
```

Alternative approach (simpler): Move all XOR MinBLEP tracking to the module level rather than in VcoEngine. This avoids modifying VcoEngine::process() signature significantly.
  </action>
  <verify>
Code compiles and runs:
1. `cd /Users/trekkie/projects/vcvrack_modules/vco && make`
2. Open VCV Rack, load module
3. Both VCOs playing, XOR waveform visible on scope (will be mixed with VCO2 in next plan)
  </verify>
  <done>XOR output is fully MinBLEP antialiased with edges tracked from both VCO1 and VCO2 transitions</done>
</task>

</tasks>

<verification>
1. Code compiles without errors: `make clean && make`
2. XOR calculation produces sqr1 * sqr2 ring modulation
3. MinBLEP discontinuities inserted for all 4 edge types:
   - VCO1 wrap (rising)
   - VCO1 PWM fall (falling)
   - VCO2 wrap (rising)
   - VCO2 PWM fall (falling)
</verification>

<success_criteria>
- VcoEngine has xorMinBlepBuffer[4] member
- process() signature extended with sqr1Input and xorOut parameters
- XOR = sqr1 * sqr2 with MinBLEP corrections from both oscillators
- PWM changes on either VCO affect XOR waveform character (dynamic PWM response)
- Code compiles and VCO loads in VCV Rack
</success_criteria>

<output>
After completion, create `.planning/phases/08-xor-waveshaping/08-01-SUMMARY.md`
</output>
