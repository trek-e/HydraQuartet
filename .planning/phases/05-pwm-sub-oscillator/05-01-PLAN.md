---
phase: 05-pwm-sub-oscillator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/HydraQuartetVCO.cpp
  - res/HydraQuartetVCO.svg
autonomous: true

must_haves:
  truths:
    - "User can modulate VCO1 PWM via CV input"
    - "User can modulate VCO2 PWM via CV input"
    - "User can invert PWM modulation using attenuverter"
    - "User can see LED activity when PWM CV is connected"
  artifacts:
    - path: "src/HydraQuartetVCO.cpp"
      provides: "PWM CV processing with attenuverters"
      contains: "PWM1_ATT_PARAM"
    - path: "src/HydraQuartetVCO.cpp"
      provides: "LED light updates for CV activity"
      contains: "PWM1_CV_LIGHT"
  key_links:
    - from: "inputs[PWM1_INPUT]"
      to: "vco1.process()"
      via: "pwm1 calculation with attenuverter"
      pattern: "pwm1CV.*pwm1Att"
    - from: "inputs[PWM2_INPUT]"
      to: "vco2.process()"
      via: "pwm2 calculation with attenuverter"
      pattern: "pwm2CV.*pwm2Att"
---

<objective>
Wire PWM CV inputs with bipolar attenuverter processing and add LED activity indicators.

Purpose: PWM CV modulation is essential for classic PWM sweep sounds and expressive performance. The attenuverters enable both depth control and polarity inversion for bidirectional modulation.

Output: Working PWM CV inputs for both VCOs with visual feedback showing modulation activity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pwm-sub-oscillator/05-CONTEXT.md
@.planning/phases/05-pwm-sub-oscillator/05-RESEARCH.md
@src/HydraQuartetVCO.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PWM CV attenuverter params and wire CV inputs</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Add attenuverter parameters and wire PWM CV inputs with bipolar processing:

1. Add to ParamId enum (after PWM1_PARAM and PWM2_PARAM):
   - PWM1_ATT_PARAM
   - PWM2_ATT_PARAM

2. Add to LightId enum:
   - PWM1_CV_LIGHT
   - PWM2_CV_LIGHT
   - LIGHTS_LEN (update count)

3. In constructor, configure new params:
```cpp
configParam(PWM1_ATT_PARAM, -1.f, 1.f, 0.f, "VCO1 PWM CV Attenuverter", "%", 0.f, 100.f);
configParam(PWM2_ATT_PARAM, -1.f, 1.f, 0.f, "VCO2 PWM CV Attenuverter", "%", 0.f, 100.f);
```

4. In process(), read attenuverter values before SIMD loop:
```cpp
float pwm1Att = params[PWM1_ATT_PARAM].getValue();
float pwm2Att = params[PWM2_ATT_PARAM].getValue();
```

5. Inside SIMD loop, replace scalar PWM broadcast with CV-modulated SIMD calculation:
```cpp
// Read polyphonic PWM CV
float_4 pwm1CV = inputs[PWM1_INPUT].getPolyVoltageSimd<float_4>(c);
float_4 pwm2CV = inputs[PWM2_INPUT].getPolyVoltageSimd<float_4>(c);

// Apply attenuverter: +/-5V * att * 0.1 = +/-0.5 contribution (full sweep range)
float_4 pwm1_4 = pwm1 + pwm1CV * pwm1Att * 0.1f;
float_4 pwm2_4 = pwm2 + pwm2CV * pwm2Att * 0.1f;

// Clamp to safe PWM range (avoid DC at extremes)
pwm1_4 = simd::clamp(pwm1_4, 0.01f, 0.99f);
pwm2_4 = simd::clamp(pwm2_4, 0.01f, 0.99f);
```

6. After SIMD loop, update LED lights based on CV activity:
```cpp
// PWM CV activity indicators
if (inputs[PWM1_INPUT].isConnected()) {
    float peakCV = 0.f;
    for (int i = 0; i < channels; i++) {
        peakCV = std::max(peakCV, std::abs(inputs[PWM1_INPUT].getVoltage(i)));
    }
    lights[PWM1_CV_LIGHT].setBrightness(peakCV / 5.f);
} else {
    lights[PWM1_CV_LIGHT].setBrightness(0.f);
}

if (inputs[PWM2_INPUT].isConnected()) {
    float peakCV = 0.f;
    for (int i = 0; i < channels; i++) {
        peakCV = std::max(peakCV, std::abs(inputs[PWM2_INPUT].getVoltage(i)));
    }
    lights[PWM2_CV_LIGHT].setBrightness(peakCV / 5.f);
} else {
    lights[PWM2_CV_LIGHT].setBrightness(0.f);
}
```

7. Remove the scalar PWM broadcast lines:
```cpp
// DELETE these lines (replaced by per-channel calculation in loop):
// float_4 pwm1_4 = pwm1;
// float_4 pwm2_4 = pwm2;
```
  </action>
  <verify>
Run `make` in plugin directory. Compilation succeeds with no errors.
  </verify>
  <done>
PWM1_ATT_PARAM and PWM2_ATT_PARAM exist, CV inputs are read with getPolyVoltageSimd, attenuverter applied, and result clamped to 0.01-0.99 range.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add attenuverter knobs and LED lights to widget</name>
  <files>src/HydraQuartetVCO.cpp</files>
  <action>
Add UI elements for attenuverters and CV activity lights:

1. In HydraQuartetVCOWidget constructor, add attenuverter knobs near PWM CV inputs:

For VCO1 (PWM CV input is at mm2px(Vec(55.88, 68.0))):
```cpp
// PWM1 attenuverter - small knob above the CV input
addParam(createParamCentered<Trimpot>(mm2px(Vec(55.88, 58.0)), module, HydraQuartetVCO::PWM1_ATT_PARAM));
// PWM1 CV activity LED - positioned near the input port
addChild(createLightCentered<SmallLight<GreenLight>>(mm2px(Vec(60.0, 68.0)), module, HydraQuartetVCO::PWM1_CV_LIGHT));
```

For VCO2 (PWM CV input is at mm2px(Vec(127.0, 85.0))):
```cpp
// PWM2 attenuverter - small knob above the CV input
addParam(createParamCentered<Trimpot>(mm2px(Vec(127.0, 75.0)), module, HydraQuartetVCO::PWM2_ATT_PARAM));
// PWM2 CV activity LED - positioned near the input port
addChild(createLightCentered<SmallLight<GreenLight>>(mm2px(Vec(131.0, 85.0)), module, HydraQuartetVCO::PWM2_CV_LIGHT));
```

Note: Use Trimpot for attenuverters (smaller than main knobs, appropriate for secondary controls). SmallLight<GreenLight> is standard VCV pattern for activity indicators.
  </action>
  <verify>
Run `make` in plugin directory. Then load module in VCV Rack and verify:
1. Small attenuverter knobs appear near PWM CV inputs
2. Green LED lights appear near each PWM CV input port
  </verify>
  <done>
Widget displays attenuverter knobs (Trimpot) and LED indicators (SmallLight<GreenLight>) at appropriate positions near PWM CV inputs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test PWM CV modulation with LFO</name>
  <files>None (testing only)</files>
  <action>
Functional verification of PWM CV implementation:

1. Load HydraQuartetVCO in VCV Rack
2. Patch an LFO (e.g., Befaco LFO) to PWM1 CV input
3. Set LFO to slow rate (~0.5 Hz)
4. Set PWM1 attenuverter to noon (0 = no modulation) - verify no PWM change
5. Turn attenuverter clockwise (positive) - verify PWM sweeps with LFO
6. Turn attenuverter counter-clockwise (negative) - verify PWM sweeps inverted
7. Set attenuverter to maximum positive - verify full PWM sweep (1% to 99%)
8. Verify green LED brightness follows LFO amplitude
9. Repeat for VCO2 PWM CV input
10. Disconnect LFO - verify LED goes dark

Listen for:
- No clicks at PWM extremes (DC filtering working)
- Smooth PWM sweep (no stepping or aliasing)
- Per-voice modulation if using polyphonic CV source
  </action>
  <verify>
Visual inspection: LED brightness follows CV amplitude.
Audio inspection: PWM sweep is smooth, no clicks, polarity inverts with negative attenuverter.
  </verify>
  <done>
PWM CV modulation works correctly: attenuverter at 0 = no modulation, positive = normal, negative = inverted. LED shows modulation activity. No audio artifacts.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `make` succeeds with no warnings related to new params
2. Module loads in VCV Rack without crashes
3. PWM1 CV input modulates VCO1 square wave pulse width
4. PWM2 CV input modulates VCO2 square wave pulse width
5. Attenuverters control modulation depth and polarity
6. LEDs show CV activity when inputs are connected
7. No clicks at PWM extremes (clamping to 0.01-0.99 working)
</verification>

<success_criteria>
- User can sweep PWM knob on VCO1 and hear pulse width change (baseline - already working)
- User can modulate VCO1 PWM via CV input with attenuverter control
- User can modulate VCO2 PWM via CV input with attenuverter control
- User can invert PWM modulation using negative attenuverter setting
- Green LED indicates when CV modulation is active and follows CV amplitude
</success_criteria>

<output>
After completion, create `.planning/phases/05-pwm-sub-oscillator/05-01-SUMMARY.md`
</output>
